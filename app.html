<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rainbet | 1.0.0 </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #1e293b;
        }

        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }

        /* Game Canvas Container - Responsive Height */
        .game-canvas-wrapper {
            position: relative;
            width: 100%;
            /* Mobile: 45% of viewport height, PC: Fixed 600px */
            height: 45vh;
            background: #1e293b;
            border-radius: 1rem;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            flex-shrink: 0;
            /* Prevent crushing on flex layouts */
        }

        @media (min-width: 1024px) {
            .game-canvas-wrapper {
                height: 600px;
            }
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .neon-text {
            text-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
        }

        .active-game-btn {
            background-color: #1e293b;
            border-color: #3b82f6;
            color: #fff;
        }

        .hidden-panel {
            display: none !important;
        }

        .stat-badge {
            font-variant-numeric: tabular-nums;
        }

        /* MINES GAME STYLES */
        .mines-grid {
            display: grid;
            gap: 0.25rem;
            /* Smaller gap on mobile */
            width: 100%;
            height: 100%;
            padding: 0.5rem;
            max-width: 500px;
            /* Prevent stretching too wide on tablet */
            margin: 0 auto;
            /* FIX: Ensure grid rows don't collapse */
            grid-auto-rows: 1fr;
        }

        @media (min-width: 768px) {
            .mines-grid {
                gap: 0.5rem;
                padding: 1rem;
            }
        }

        .mine-tile {
            background-color: #334155;
            border-radius: 0.3rem;
            cursor: pointer;
            transition: transform 0.1s, background-color 0.1s;
            /* Animate only safe properties */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            /* Fixed font size */
            border-bottom: 4px solid #1e293b;
            /* Increased slightly for better 3D effect */
            user-select: none;

            /* FIX: Lock the shape to prevent mutation */
            aspect-ratio: 1;
            overflow: hidden;
            /* Prevent emoji from pushing bounds */
            height: 100%;
            width: 100%;
            box-sizing: border-box;
            /* Include border in size */
        }

        .mine-tile:active:not(.revealed):not(.game-over) {
            /* FIX: Don't change border-width or margin. Just move it and hide the shadow color */
            transform: translateY(2px);
            border-bottom-color: #334155;
            /* Match face color to look flat */
        }

        .mine-tile.revealed {
            background-color: #0f172a;
            /* FIX: Keep the border width exactly the same (4px), just change color to background */
            border-bottom: 4px solid #0f172a;
            cursor: default;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            transform: none;
            /* Reset any active transforms */
        }

        .mine-tile.gem {
            color: #34d399;
            text-shadow: 0 0 10px rgba(52, 211, 153, 0.5);
        }

        .mine-tile.bomb {
            background-color: #7f1d1d;
            color: #f87171;
            border: 2px solid #ef4444;
        }

        @keyframes gemPop {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .animate-gem {
            animation: gemPop 0.3s ease-out forwards;
        }

        /* Mobile Nav Horizontal Scroll */
        .mobile-nav-scroll {
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            /* Firefox */
        }

        .mobile-nav-scroll::-webkit-scrollbar {
            display: none;
            /* Chrome/Safari */
        }
    </style>
</head>

<body class="h-screen flex flex-col fixed w-full inset-0">

    <!-- Header -->
    <header class="bg-slate-900 border-b border-slate-800 p-3 shadow-lg z-20 flex-shrink-0">
        <div class="max-w-7xl mx-auto flex justify-between items-center">
            <div class="flex items-center gap-2">
                <div
                    class="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center font-bold text-lg shadow-lg shadow-blue-500/30">
                    R</div>
                <div>
                    <h1 class="font-bold text-lg tracking-tight text-white leading-tight">Rainbet</h1>
                    <p class="text-[10px] text-slate-400 hidden sm:block">Online Casino</p>
                </div>
            </div>

            <!-- Credits -->
            <div
                class="flex items-center gap-2 bg-slate-800 px-3 py-1.5 rounded-full border border-slate-700 shadow-inner">
                <span
                    class="text-slate-400 text-xs font-semibold uppercase tracking-wider hidden sm:inline">Balance</span>
                <span id="credit-display" class="text-lg font-mono font-bold text-emerald-400 neon-text">1000.00</span>


                <button onclick="GameConfig.resetCredits()"
                    class="ml-1 text-[10px] text-slate-500 hover:text-white underline p-1">Reset</button>

                <button onclick="GameConfig.openBackupModal()"
                    class="ml-1 text-[10px] text-blue-400 hover:text-white underline p-1">Backup</button>
            </div>
        </div>
    </header>

    <!-- Backup Modal -->
    <div id="backup-modal" class="fixed inset-0 bg-black/80 z-50 hidden flex items-center justify-center p-4">
        <div class="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-md w-full shadow-2xl">
            <h3 class="text-xl font-bold text-white mb-4">Data Backup</h3>
            <p class="text-sm text-slate-400 mb-4">
                Google Sites may clear your data. Use this code to save or restore your progress manually.
            </p>

            <div class="mb-4">
                <label class="block text-xs font-semibold text-slate-500 uppercase mb-1">Your Save Code</label>
                <div class="flex gap-2">
                    <input id="backup-export-field" readonly
                        class="flex-1 bg-slate-950 border border-slate-800 rounded px-3 py-2 text-xs font-mono text-emerald-400 select-all">
                    <button onclick="GameConfig.copySave()"
                        class="bg-blue-600 text-white px-3 py-2 rounded text-xs font-bold whitespace-nowrap">Copy</button>
                </div>
            </div>

            <div class="mb-6">
                <label class="block text-xs font-semibold text-slate-500 uppercase mb-1">Import Code</label>
                <div class="flex gap-2">
                    <input id="backup-import-field" placeholder="Paste code here..."
                        class="flex-1 bg-slate-950 border border-slate-800 rounded px-3 py-2 text-xs font-mono text-white focus:border-blue-500 outline-none">
                    <button onclick="GameConfig.importSave()"
                        class="bg-emerald-600 text-white px-3 py-2 rounded text-xs font-bold whitespace-nowrap">Load</button>
                </div>
            </div>

            <div class="text-right">
                <button onclick="document.getElementById('backup-modal').classList.add('hidden')"
                    class="text-slate-400 hover:text-white text-sm">Close</button>
            </div>
        </div>
    </div>

    <!-- Mobile Nav Bar (Visible only on small screens) -->
    <div class="md:hidden bg-slate-900 border-b border-slate-800 py-2 flex-shrink-0">
        <div class="mobile-nav-scroll flex gap-2 overflow-x-auto px-4">
            <button id="mob-nav-plinko" onclick="GameUI.switchGame('plinko')"
                class="flex-shrink-0 px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-bold shadow-lg shadow-blue-900/20 whitespace-nowrap">üîª
                Plinko</button>
            <button id="mob-nav-roulette" onclick="GameUI.switchGame('roulette')"
                class="flex-shrink-0 px-4 py-2 bg-slate-800 text-slate-400 rounded-lg text-sm font-bold whitespace-nowrap">üé°
                Roulette</button>
            <button id="mob-nav-slots" onclick="GameUI.switchGame('slots')"
                class="flex-shrink-0 px-4 py-2 bg-slate-800 text-slate-400 rounded-lg text-sm font-bold whitespace-nowrap">üé∞
                Slots</button>
            <button id="mob-nav-dice" onclick="GameUI.switchGame('dice')"
                class="flex-shrink-0 px-4 py-2 bg-slate-800 text-slate-400 rounded-lg text-sm font-bold whitespace-nowrap">üé≤
                Dice</button>
            <button id="mob-nav-blackjack" onclick="GameUI.switchGame('blackjack')"
                class="flex-shrink-0 px-4 py-2 bg-slate-800 text-slate-400 rounded-lg text-sm font-bold whitespace-nowrap">üÉè
                Blackjack</button>
            <button id="mob-nav-mines" onclick="GameUI.switchGame('mines')"
                class="flex-shrink-0 px-4 py-2 bg-slate-800 text-slate-400 rounded-lg text-sm font-bold whitespace-nowrap">üí£
                Mines</button>
            <button id="mob-nav-rocket" onclick="GameUI.switchGame('rocket')"
                class="flex-shrink-0 px-4 py-2 bg-slate-800 text-slate-400 rounded-lg text-sm font-bold whitespace-nowrap">üöÄ
                Rocket</button>
            <button id="mob-nav-cases" onclick="GameUI.switchGame('cases')"
                class="flex-shrink-0 px-4 py-2 bg-slate-800 text-slate-400 rounded-lg text-sm font-bold whitespace-nowrap">üì¶
                Cases</button>
            <button id="mob-nav-poker" onclick="GameUI.switchGame('poker')"
                class="flex-shrink-0 px-4 py-2 bg-slate-800 text-slate-400 rounded-lg text-sm font-bold whitespace-nowrap">‚ô†Ô∏è
                Poker</button>
            <button id="mob-nav-scratch" onclick="GameUI.switchGame('scratch')"
                class="flex-shrink-0 px-4 py-2 bg-slate-800 text-slate-400 rounded-lg text-sm font-bold whitespace-nowrap">üé´
                Scratch</button>
            <button id="mob-nav-stats" onclick="GameUI.switchGame('stats')"
                class="flex-shrink-0 px-4 py-2 bg-slate-800 text-slate-400 rounded-lg text-sm font-bold whitespace-nowrap">üìà
                Stats</button>
        </div>
    </div>

    <!-- Main Content Area -->
    <main class="flex-1 flex overflow-hidden relative">

        <!-- PC Sidebar (Hidden on mobile) -->
        <aside
            class="w-64 bg-slate-900 border-r border-slate-800 flex flex-col hidden md:flex flex-shrink-0 h-full overflow-y-auto scrollbar-thin scrollbar-thumb-slate-700">
            <div class="p-4">
                <h3 class="text-xs font-semibold text-slate-500 uppercase tracking-wider mb-4">Available Games</h3>
                <nav class="space-y-2">
                    <button id="nav-plinko" onclick="GameUI.switchGame('plinko')"
                        class="active-game-btn w-full flex items-center gap-3 px-4 py-3 rounded-lg border border-transparent shadow-sm transition hover:bg-slate-800">
                        <span class="text-2xl">üîª</span>
                        <div class="text-left">
                            <div class="font-bold">Plinko</div>
                            <div class="text-xs text-slate-400">Normal Distribution</div>
                        </div>
                    </button>

                    <button id="nav-roulette" onclick="GameUI.switchGame('roulette')"
                        class="w-full flex items-center gap-3 px-4 py-3 text-slate-400 rounded-lg border border-transparent transition hover:bg-slate-800 hover:text-white">
                        <span class="text-2xl">üé°</span>
                        <div class="text-left">
                            <div class="font-bold">Roulette</div>
                            <div class="text-xs text-slate-500">American (0, 00)</div>
                        </div>
                    </button>

                    <button id="nav-slots" onclick="GameUI.switchGame('slots')"
                        class="w-full flex items-center gap-3 px-4 py-3 text-slate-400 rounded-lg border border-transparent transition hover:bg-slate-800 hover:text-white">
                        <span class="text-2xl">üé∞</span>
                        <div class="text-left">
                            <div class="font-bold">Slots</div>
                            <div class="text-xs text-slate-500">3, 4, 5 Reel Modes</div>
                        </div>
                    </button>

                    <button id="nav-dice" onclick="GameUI.switchGame('dice')"
                        class="w-full flex items-center gap-3 px-4 py-3 text-slate-400 rounded-lg border border-transparent transition hover:bg-slate-800 hover:text-white">
                        <span class="text-2xl">üé≤</span>
                        <div class="text-left">
                            <div class="font-bold">Dice Roll</div>
                            <div class="text-xs text-slate-500">Probabilities</div>
                        </div>
                    </button>

                    <button id="nav-blackjack" onclick="GameUI.switchGame('blackjack')"
                        class="w-full flex items-center gap-3 px-4 py-3 text-slate-400 rounded-lg border border-transparent transition hover:bg-slate-800 hover:text-white">
                        <span class="text-2xl">üÉè</span>
                        <div class="text-left">
                            <div class="font-bold">Blackjack</div>
                            <div class="text-xs text-slate-500">Dependent Events</div>
                        </div>
                    </button>

                    <button id="nav-mines" onclick="GameUI.switchGame('mines')"
                        class="w-full flex items-center gap-3 px-4 py-3 text-slate-400 rounded-lg border border-transparent transition hover:bg-slate-800 hover:text-white">
                        <span class="text-2xl">üí£</span>
                        <div class="text-left">
                            <div class="font-bold">Mines</div>
                            <div class="text-xs text-slate-500">Compound Probability</div>
                        </div>
                    </button>

                    <button id="nav-rocket" onclick="GameUI.switchGame('rocket')"
                        class="w-full flex items-center gap-3 px-4 py-3 text-slate-400 rounded-lg border border-transparent transition hover:bg-slate-800 hover:text-white">
                        <span class="text-2xl">üöÄ</span>
                        <div class="text-left">
                            <div class="font-bold">Rocket</div>
                            <div class="text-xs text-slate-500">Exponential Growth</div>
                        </div>
                    </button>

                    <button id="nav-cases" onclick="GameUI.switchGame('cases')"
                        class="w-full flex items-center gap-3 px-4 py-3 text-slate-400 rounded-lg border border-transparent transition hover:bg-slate-800 hover:text-white">
                        <span class="text-2xl">üì¶</span>
                        <div class="text-left">
                            <div class="font-bold">Cases</div>
                            <div class="text-xs text-slate-500">Loot Boxes</div>
                        </div>
                    </button>

                    <button id="nav-poker" onclick="GameUI.switchGame('poker')"
                        class="w-full flex items-center gap-3 px-4 py-3 text-slate-400 rounded-lg border border-transparent transition hover:bg-slate-800 hover:text-white">
                        <span class="text-2xl">‚ô†Ô∏è</span>
                        <div class="text-left">
                            <div class="font-bold">Poker</div>
                            <div class="text-xs text-slate-500">Texas Hold'em</div>
                        </div>
                    </button>

                    <button id="nav-scratch" onclick="GameUI.switchGame('scratch')"
                        class="w-full flex items-center gap-3 px-4 py-3 text-slate-400 rounded-lg border border-transparent transition hover:bg-slate-800 hover:text-white">
                        <span class="text-2xl">üé´</span>
                        <div class="text-left">
                            <div class="font-bold">Scratch Cards</div>
                            <div class="text-xs text-slate-500">Instant Wins</div>
                        </div>
                    </button>

                    <button id="nav-stats" onclick="GameUI.switchGame('stats')"
                        class="w-full flex items-center gap-3 px-4 py-3 text-slate-400 rounded-lg border border-transparent transition hover:bg-slate-800 hover:text-white">
                        <span class="text-2xl">üìà</span>
                        <div class="text-left">
                            <div class="font-bold">Stats</div>
                            <div class="text-xs text-slate-500">Balance History</div>
                        </div>
                    </button>

                    <!-- Update Log Button -->
                    <button onclick="GameUI.toggleUpdates()"
                        class="w-full mt-4 flex items-center gap-3 px-4 py-3 text-emerald-400 bg-slate-950/50 rounded-lg border border-slate-800 transition hover:bg-slate-950 hover:text-emerald-300">
                        <span class="text-2xl">üìú</span>
                        <div class="text-left">
                            <div class="font-bold">Updates</div>
                            <div class="text-xs text-emerald-500/70">View Changelog</div>
                        </div>
                    </button>
                </nav>
            </div>
        </aside>

        <!-- Game Area -->
        <div class="flex-1 bg-slate-950 relative overflow-y-auto">
            <div class="max-w-6xl mx-auto p-4 md:p-8 min-h-full">

                <!-- Layout: Flex col-reverse on mobile (Controls below Visualizer), Grid on PC -->
                <div class="flex flex-col lg:grid lg:grid-cols-4 gap-4 h-full">

                    <!-- Controls Panel (Order 2 on Mobile) - Scrollable -->
                    <div
                        class="lg:col-span-1 space-y-4 order-2 lg:order-1 pb-8 lg:pb-0 lg:max-h-[calc(100vh-8rem)] lg:overflow-y-auto lg:pr-2">

                        <!-- PLINKO CONTROLS -->
                        <div id="controls-plinko" class="bg-slate-900 p-4 rounded-xl border border-slate-800 shadow-xl">
                            <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">‚öôÔ∏è Plinko</h2>
                            <div class="mb-4">
                                <label class="block text-xs font-semibold text-slate-400 uppercase mb-2">Bet
                                    Amount</label>
                                <div class="relative">
                                    <input type="number" id="bet-input-plinko" value="10" min="1" max="100"
                                        class="w-full bg-slate-950 border border-slate-700 rounded-lg py-3 px-3 text-white font-mono focus:outline-none focus:border-blue-500">
                                    <div class="grid grid-cols-2 gap-2 mt-2">
                                        <button onclick="GameUI.adjustBet('plinko', 0.5)"
                                            class="bg-slate-800 text-white p-2 rounded text-xs border border-slate-700">1/2</button>
                                        <button onclick="GameUI.adjustBet('plinko', 2)"
                                            class="bg-slate-800 text-white p-2 rounded text-xs border border-slate-700">x2</button>
                                    </div>
                                </div>
                            </div>
                            <div class="mb-4">
                                <label class="block text-xs font-semibold text-slate-400 uppercase mb-2">Rows</label>
                                <select id="rows-select"
                                    class="w-full bg-slate-950 border border-slate-700 rounded-lg py-3 px-3 text-white">
                                    <option value="9">9 Rows</option>
                                    <option value="13" selected>13 Rows</option>
                                    <option value="17">17 Rows</option>
                                </select>
                            </div>
                            <button id="play-btn-plinko"
                                class="w-full bg-blue-600 text-white font-bold py-4 rounded-lg shadow-lg active:scale-95 transition-transform">DROP
                                BALL</button>
                        </div>

                        <!-- SLOTS CONTROLS -->
                        <div id="controls-slots"
                            class="hidden-panel bg-slate-900 p-4 rounded-xl border border-slate-800 shadow-xl">
                            <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">üé∞ Slots</h2>
                            <div class="mb-4">
                                <label class="block text-xs font-semibold text-slate-400 uppercase mb-2">Bet
                                    Amount</label>
                                <div class="relative">
                                    <input type="number" id="bet-input-slots" value="10" min="1" max="100"
                                        class="w-full bg-slate-950 border border-slate-700 rounded-lg py-3 px-3 text-white font-mono focus:outline-none focus:border-blue-500">
                                    <div class="grid grid-cols-2 gap-2 mt-2">
                                        <button onclick="GameUI.adjustBet('slots', 0.5)"
                                            class="bg-slate-800 text-white p-2 rounded text-xs border border-slate-700">1/2</button>
                                        <button onclick="GameUI.adjustBet('slots', 2)"
                                            class="bg-slate-800 text-white p-2 rounded text-xs border border-slate-700">x2</button>
                                    </div>
                                </div>
                            </div>
                            <div class="mb-4">
                                <label class="block text-xs font-semibold text-slate-400 uppercase mb-2">Reels
                                    (Mode)</label>
                                <div class="grid grid-cols-3 gap-2">
                                    <button onclick="GameUI.slots.setMode(3)" id="slots-mode-3"
                                        class="bg-blue-600 text-white p-2 rounded text-xs font-bold border border-transparent">3</button>
                                    <button onclick="GameUI.slots.setMode(4)" id="slots-mode-4"
                                        class="bg-slate-800 text-slate-400 p-2 rounded text-xs font-bold border border-slate-700">4</button>
                                    <button onclick="GameUI.slots.setMode(5)" id="slots-mode-5"
                                        class="bg-slate-800 text-slate-400 p-2 rounded text-xs font-bold border border-slate-700">5</button>
                                </div>
                            </div>
                            <button id="play-btn-slots" onclick="GameUI.slots.spin()"
                                class="w-full bg-emerald-600 text-white font-bold py-4 rounded-lg shadow-lg active:scale-95 transition-transform">SPIN</button>
                            <div class="mt-4 text-center">
                                <div id="slots-result" class="text-sm font-bold h-6 text-slate-300">Good Luck!</div>
                            </div>
                        </div>

                        <!-- ROULETTE CONTROLS -->
                        <div id="controls-roulette"
                            class="hidden-panel bg-slate-900 p-4 rounded-xl border border-slate-800 shadow-xl">
                            <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">üé° Roulette</h2>
                            <div class="mb-4">
                                <label class="block text-xs font-semibold text-slate-400 uppercase mb-2">Bet
                                    Amount</label>
                                <div class="relative">
                                    <input type="number" id="bet-input-roulette" value="10" min="1" max="100"
                                        class="w-full bg-slate-950 border border-slate-700 rounded-lg py-3 px-3 text-white font-mono focus:outline-none focus:border-blue-500">
                                    <div class="grid grid-cols-2 gap-2 mt-2">
                                        <button onclick="GameUI.adjustBet('roulette', 0.5)"
                                            class="bg-slate-800 text-white p-2 rounded text-xs border border-slate-700">1/2</button>
                                        <button onclick="GameUI.adjustBet('roulette', 2)"
                                            class="bg-slate-800 text-white p-2 rounded text-xs border border-slate-700">x2</button>
                                    </div>
                                </div>
                            </div>

                            <!-- Color/Parity Bets -->
                            <div class="grid grid-cols-2 gap-2 mb-2">
                                <button onclick="GameUI.playRoulette('red')"
                                    class="bg-red-600 hover:bg-red-500 text-white font-bold py-3 rounded text-sm border-b-4 border-red-800 active:border-b-0 active:translate-y-1 transition-all">Red
                                    (x2)</button>
                                <button onclick="GameUI.playRoulette('black')"
                                    class="bg-slate-700 hover:bg-slate-600 text-white font-bold py-3 rounded text-sm border-b-4 border-slate-900 active:border-b-0 active:translate-y-1 transition-all">Black
                                    (x2)</button>
                                <button onclick="GameUI.playRoulette('even')"
                                    class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 rounded text-sm border-b-4 border-blue-800 active:border-b-0 active:translate-y-1 transition-all">Even
                                    (x2)</button>
                                <button onclick="GameUI.playRoulette('odd')"
                                    class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 rounded text-sm border-b-4 border-blue-800 active:border-b-0 active:translate-y-1 transition-all">Odd
                                    (x2)</button>
                            </div>

                            <!-- Zero Bets -->
                            <div class="grid grid-cols-2 gap-2 mb-4">
                                <button onclick="GameUI.playRoulette('0')"
                                    class="bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-2 rounded text-sm border-b-4 border-emerald-800 active:border-b-0 active:translate-y-1 transition-all">0
                                    (x35)</button>
                                <button onclick="GameUI.playRoulette('00')"
                                    class="bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-2 rounded text-sm border-b-4 border-emerald-800 active:border-b-0 active:translate-y-1 transition-all">00
                                    (x35)</button>
                            </div>

                            <!-- Single Number Bet -->
                            <div class="bg-slate-800 p-2 rounded border border-slate-700">
                                <label class="block text-[10px] font-semibold text-slate-400 uppercase mb-1">Single
                                    Number (1-36)</label>
                                <div class="flex gap-2">
                                    <input type="number" id="roulette-single-num" min="1" max="36" placeholder="#"
                                        class="w-16 bg-slate-950 border border-slate-600 rounded px-2 text-white font-mono text-center">
                                    <button onclick="GameUI.playRoulette('number')"
                                        class="flex-1 bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 rounded text-sm shadow active:scale-95">Bet
                                        (x35)</button>
                                </div>
                            </div>

                            <div class="mt-4 text-center">
                                <div id="roulette-result" class="text-sm font-bold h-6 text-slate-300">Place your bets!
                                </div>
                            </div>
                        </div>

                        <!-- DICE CONTROLS -->
                        <div id="controls-dice"
                            class="hidden-panel bg-slate-900 p-4 rounded-xl border border-slate-800 shadow-xl">
                            <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">üé≤ Dice</h2>
                            <div class="mb-4">
                                <label class="block text-xs font-semibold text-slate-400 uppercase mb-2">Bet
                                    Amount</label>
                                <div class="relative">
                                    <input type="number" id="bet-input-dice" value="10" min="1" max="100"
                                        class="w-full bg-slate-950 border border-slate-700 rounded-lg py-3 px-3 text-white font-mono">
                                    <div class="grid grid-cols-2 gap-2 mt-2">
                                        <button onclick="GameUI.adjustBet('dice', 0.5)"
                                            class="bg-slate-800 text-white p-2 rounded text-xs border border-slate-700">1/2</button>
                                        <button onclick="GameUI.adjustBet('dice', 2)"
                                            class="bg-slate-800 text-white p-2 rounded text-xs border border-slate-700">x2</button>
                                    </div>
                                </div>
                            </div>
                            <div class="space-y-2">
                                <button onclick="GameUI.playDice('under')"
                                    class="w-full flex justify-between items-center bg-slate-800 p-3 rounded-lg border border-slate-700 active:scale-95">
                                    <div class="text-left">
                                        <div class="font-bold text-sm text-white">Under 7</div>
                                    </div>
                                    <div class="text-emerald-400 font-mono font-bold">2.3x</div>
                                </button>
                                <button onclick="GameUI.playDice('exact')"
                                    class="w-full flex justify-between items-center bg-slate-800 p-3 rounded-lg border border-slate-700 active:scale-95">
                                    <div class="text-left">
                                        <div class="font-bold text-sm text-white">Exactly 7</div>
                                    </div>
                                    <div class="text-purple-400 font-mono font-bold">5.8x</div>
                                </button>
                                <button onclick="GameUI.playDice('over')"
                                    class="w-full flex justify-between items-center bg-slate-800 p-3 rounded-lg border border-slate-700 active:scale-95">
                                    <div class="text-left">
                                        <div class="font-bold text-sm text-white">Over 7</div>
                                    </div>
                                    <div class="text-emerald-400 font-mono font-bold">2.3x</div>
                                </button>
                            </div>
                        </div>

                        <!-- BLACKJACK CONTROLS -->
                        <div id="controls-blackjack"
                            class="hidden-panel bg-slate-900 p-4 rounded-xl border border-slate-800 shadow-xl">
                            <div class="flex justify-between items-center mb-4">
                                <h2 class="text-lg font-bold text-white">üÉè Blackjack</h2>
                            </div>
                            <div class="mb-4">
                                <label class="block text-xs font-semibold text-slate-400 uppercase mb-2">Bet
                                    Amount</label>
                                <input type="number" id="bet-input-blackjack" value="10" min="1" max="100"
                                    class="w-full bg-slate-950 border border-slate-700 rounded-lg py-3 px-3 text-white font-mono">
                            </div>

                            <!-- Removed Stats Panel and Toggle Button -->

                            <div class="grid grid-cols-2 gap-3">
                                <!-- SPLIT & DOUBLE ROW -->
                                <button id="bj-btn-split" onclick="GameUI.blackjackAction('split')"
                                    class="hidden bg-purple-600 text-white font-bold py-3 rounded-lg disabled:opacity-50 transition active:scale-95">SPLIT</button>
                                <button id="bj-btn-double" onclick="GameUI.blackjackAction('double')"
                                    class="bg-indigo-600 text-white font-bold py-3 rounded-lg disabled:opacity-50 transition active:scale-95">DOUBLE</button>

                                <!-- MAIN ACTIONS -->
                                <button id="bj-btn-hit" onclick="GameUI.blackjackAction('hit')"
                                    class="bg-blue-600 text-white font-bold py-4 rounded-lg disabled:opacity-50 shadow-lg active:scale-95">HIT</button>
                                <button id="bj-btn-stand" onclick="GameUI.blackjackAction('stand')"
                                    class="bg-amber-600 text-white font-bold py-4 rounded-lg disabled:opacity-50 shadow-lg active:scale-95">STAND</button>

                                <!-- DEAL BUTTON -->
                                <button id="bj-btn-deal" onclick="GameUI.blackjackAction('deal')"
                                    class="col-span-2 bg-emerald-600 text-white font-bold py-4 rounded-lg shadow-lg active:scale-95">DEAL</button>
                            </div>
                        </div>

                        <!-- MINES CONTROLS -->
                        <div id="controls-mines"
                            class="hidden-panel bg-slate-900 p-4 rounded-xl border border-slate-800 shadow-xl">
                            <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">üí£ Mines</h2>
                            <div class="grid grid-cols-2 gap-2 mb-4">
                                <div>
                                    <label
                                        class="block text-[10px] font-semibold text-slate-400 uppercase mb-1">Bet</label>
                                    <input type="number" id="bet-input-mines" value="10"
                                        class="w-full bg-slate-950 border border-slate-700 rounded-lg py-2 px-2 text-white font-mono">
                                </div>
                                <div>
                                    <label
                                        class="block text-[10px] font-semibold text-slate-400 uppercase mb-1">Mines</label>
                                    <input type="number" id="mines-count-input" value="3" min="1" max="35"
                                        class="w-full bg-slate-950 border border-slate-700 rounded-lg py-2 px-2 text-white font-mono">
                                </div>
                            </div>
                            <div class="mb-4">
                                <label
                                    class="block text-[10px] font-semibold text-slate-400 uppercase mb-1">Grid</label>
                                <select id="mines-grid-select" onchange="GameUI.mines.updateGridConfig()"
                                    class="w-full bg-slate-950 border border-slate-700 rounded-lg py-2 px-2 text-white">
                                    <option value="3">3x3 (Easy)</option>
                                    <option value="5" selected>5x5 (Medium)</option>
                                    <option value="7">7x7 ({ Hard })</option>
                                    <option value="9">9x9 (Expert)</option>
                                </select>
                            </div>
                            <div id="mines-status"
                                class="hidden mb-4 p-2 bg-slate-950 rounded border border-blue-900 text-center">
                                <div class="text-[10px] text-slate-400 uppercase">Win</div>
                                <div id="mines-current-win" class="text-lg font-bold text-emerald-400 font-mono">0.00
                                </div>
                                <div id="mines-next-mult" class="text-[10px] text-blue-400">Next: x1.00</div>
                            </div>
                            <button id="mines-btn-start" onclick="GameUI.mines.startGame()"
                                class="w-full bg-blue-600 text-white font-bold py-4 rounded-lg shadow-lg active:scale-95">START</button>
                            <button id="mines-btn-cashout" onclick="GameUI.mines.cashout()"
                                class="hidden w-full bg-emerald-600 text-white font-bold py-4 rounded-lg shadow-lg active:scale-95">CASHOUT</button>
                        </div>

                        <!-- ROCKET CONTROLS -->
                        <div id="controls-rocket"
                            class="hidden-panel bg-slate-900 p-4 rounded-xl border border-slate-800 shadow-xl">
                            <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">üöÄ Rocket</h2>
                            <div class="mb-4">
                                <label class="block text-xs font-semibold text-slate-400 uppercase mb-2">Bet
                                    Amount</label>
                                <div class="relative">
                                    <input type="number" id="bet-input-rocket" value="10" min="1" max="100"
                                        class="w-full bg-slate-950 border border-slate-700 rounded-lg py-3 px-3 text-white font-mono focus:outline-none focus:border-blue-500">
                                    <div class="grid grid-cols-2 gap-2 mt-2">
                                        <button onclick="GameUI.adjustBet('rocket', 0.5)"
                                            class="bg-slate-800 text-white p-2 rounded text-xs border border-slate-700">1/2</button>
                                        <button onclick="GameUI.adjustBet('rocket', 2)"
                                            class="bg-slate-800 text-white p-2 rounded text-xs border border-slate-700">x2</button>
                                    </div>
                                </div>
                            </div>

                            <div class="mb-4">
                                <label class="block text-xs font-semibold text-slate-400 uppercase mb-2">Auto Eject
                                    (Optional)</label>
                                <input type="number" id="rocket-auto-cashout" placeholder="e.g. 2.00" step="0.01"
                                    class="w-full bg-slate-950 border border-slate-700 rounded-lg py-3 px-3 text-white font-mono focus:outline-none focus:border-blue-500">
                            </div>

                            <div class="mb-4 bg-slate-950 p-2 rounded border border-slate-800">
                                <div class="text-[10px] text-slate-500 uppercase">Current Seed</div>
                                <div id="rocket-seed-display" class="font-mono text-xs text-blue-400 truncate">
                                    Initializing...</div>
                            </div>

                            <button id="rocket-btn-launch" onclick="GameUI.rocket.launch()"
                                class="w-full bg-blue-600 text-white font-bold py-4 rounded-lg shadow-lg active:scale-95 transition-transform">
                                LAUNCH üöÄ
                            </button>
                            <button id="rocket-btn-eject" onclick="GameUI.rocket.eject()"
                                class="hidden w-full bg-emerald-600 text-white font-bold py-4 rounded-lg shadow-lg active:scale-95 transition-transform">
                                EJECT
                            </button>
                        </div>

                        <!-- CASES CONTROLS -->
                        <!-- CASES CONTROLS -->
                        <div id="controls-cases"
                            class="hidden-panel bg-slate-900 p-4 rounded-xl border border-slate-800 shadow-xl">
                            <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">üì¶ Cases</h2>

                            <div class="mb-4 bg-slate-950 p-3 rounded-lg border border-slate-800 text-center">
                                <div class="text-[10px] text-slate-500 uppercase tracking-widest mb-1">Cost</div>
                                <div id="cases-price-display" class="text-2xl font-mono font-bold text-white">Select
                                    Case</div>
                            </div>

                            <button id="play-btn-cases"
                                class="w-full bg-slate-700 text-slate-400 font-bold py-4 rounded-lg shadow-lg cursor-default transition-all duration-200">
                                SELECT A CASE
                            </button>

                            <div class="mt-4 text-center">
                                <div id="cases-result" class="text-sm font-bold h-6 text-slate-300">Win up to 1000x!
                                </div>
                            </div>
                        </div>

                        <!-- POKER CONTROLS -->
                        <!-- POKER CONTROLS -->
                        <div id="controls-poker"
                            class="hidden-panel bg-slate-900 p-4 rounded-xl border border-slate-800 shadow-xl">
                            <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">‚ô†Ô∏è Texas Hold'em</h2>

                            <!-- LOBBY (Table Selection) -->
                            <div id="poker-lobby" class="space-y-4">
                                <div class="text-xs text-slate-400 uppercase font-bold mb-2">Select Table (Big Blind)
                                </div>
                                <div class="grid grid-cols-1 gap-2">
                                    <button onclick="GameUI.poker.joinTable(0)"
                                        class="w-full bg-slate-800 hover:bg-slate-700 text-left px-4 py-3 rounded-lg border border-slate-700 flex justify-between items-center group">
                                        <span class="text-slate-300 font-bold group-hover:text-white">Micro
                                            Stakes</span>
                                        <span class="text-emerald-400 font-mono">$10 BB</span>
                                    </button>
                                    <button onclick="GameUI.poker.joinTable(1)"
                                        class="w-full bg-slate-800 hover:bg-slate-700 text-left px-4 py-3 rounded-lg border border-slate-700 flex justify-between items-center group">
                                        <span class="text-slate-300 font-bold group-hover:text-white">Low Stakes</span>
                                        <span class="text-emerald-400 font-mono">$50 BB</span>
                                    </button>
                                    <button onclick="GameUI.poker.joinTable(2)"
                                        class="w-full bg-slate-800 hover:bg-slate-700 text-left px-4 py-3 rounded-lg border border-slate-700 flex justify-between items-center group">
                                        <span class="text-slate-300 font-bold group-hover:text-white">Mid Stakes</span>
                                        <span class="text-emerald-400 font-mono">$100 BB</span>
                                    </button>
                                    <button onclick="GameUI.poker.joinTable(3)"
                                        class="w-full bg-slate-800 hover:bg-slate-700 text-left px-4 py-3 rounded-lg border border-slate-700 flex justify-between items-center group">
                                        <span class="text-slate-300 font-bold group-hover:text-white">High Stakes</span>
                                        <span class="text-emerald-400 font-mono">$500 BB</span>
                                    </button>
                                    <button onclick="GameUI.poker.joinTable(4)"
                                        class="w-full bg-slate-800 hover:bg-slate-700 text-left px-4 py-3 rounded-lg border border-slate-700 flex justify-between items-center group">
                                        <span class="text-slate-300 font-bold group-hover:text-white">High Roller</span>
                                        <span class="text-emerald-400 font-mono">$1000 BB</span>
                                    </button>
                                </div>
                            </div>

                            <!-- GAMEPLAY CONTROLS (Hidden in Lobby) -->
                            <div id="poker-gameplay" class="hidden">
                                <!-- Game Info -->
                                <div
                                    class="grid grid-cols-2 gap-2 mb-4 bg-slate-950 p-2 rounded border border-slate-800">
                                    <div class="text-center">
                                        <div class="text-[10px] text-slate-500 uppercase">Pot</div>
                                        <div id="poker-pot" class="font-mono text-emerald-400 font-bold">$0</div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-[10px] text-slate-500 uppercase">Current Bet</div>
                                        <div id="poker-current-bet" class="font-mono text-white font-bold">$0</div>
                                    </div>
                                </div>

                                <div class="flex justify-between items-center mb-2">
                                    <div class="text-xs text-slate-500 uppercase" id="poker-table-info">Table: $10 BB
                                    </div>
                                    <button onclick="GameUI.poker.leaveTable()"
                                        class="text-[10px] text-red-400 hover:text-red-300 uppercase font-bold border border-red-900/50 px-2 py-1 rounded bg-slate-950">Leave</button>
                                </div>

                                <div class="mb-4">
                                    <label class="block text-xs font-semibold text-slate-400 uppercase mb-2">Your
                                        Action</label>
                                    <div class="flex flex-col gap-2">
                                        <div class="flex gap-2">
                                            <button id="poker-btn-fold" onclick="GameUI.poker.fold()"
                                                class="flex-1 bg-red-900/50 hover:bg-red-900 text-red-200 font-bold py-3 rounded-lg border border-red-800 transition">Fold</button>
                                            <button id="poker-btn-check" onclick="GameUI.poker.checkCall()"
                                                class="flex-1 bg-slate-700 hover:bg-slate-600 text-white font-bold py-3 rounded-lg border border-slate-600 transition">Check</button>
                                        </div>

                                        <!-- Raise Controls -->
                                        <div class="bg-slate-950 p-2 rounded border border-slate-800">
                                            <div class="flex justify-between text-xs text-slate-400 mb-1">
                                                <span>Raise</span>
                                                <span id="poker-raise-val" class="text-white font-mono">$0</span>
                                            </div>
                                            <input type="range" id="poker-raise-slider"
                                                class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer mb-2 accent-blue-500"
                                                min="0" max="100" value="0"
                                                oninput="GameUI.poker.updateRaiseVal(this.value)">
                                            <button id="poker-btn-raise" onclick="GameUI.poker.raise()"
                                                class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 rounded shadow-lg active:scale-95 transition text-xs">CONFIRM
                                                RAISE</button>
                                        </div>
                                    </div>
                                </div>

                                <div id="poker-status" class="text-xs text-center text-slate-400 h-4 min-h-[1rem]">
                                    Waiting to deal...</div>
                                <button id="poker-btn-deal" onclick="GameUI.poker.nextHand()"
                                    class="w-full mt-4 bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-3 rounded-lg shadow-lg active:scale-95 transition hidden">Deal
                                    Next Hand</button>
                            </div>
                        </div>

                        <!-- SCRATCH CONTROLS -->
                        <div id="controls-scratch"
                            class="hidden-panel bg-slate-900 p-4 rounded-xl border border-slate-800 shadow-xl">
                            <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">üé´ Scratchers</h2>
                            <div class="mb-4">
                                <label class="block text-xs font-semibold text-slate-400 uppercase mb-2">Select
                                    Ticket</label>
                                <select id="scratch-ticket-select" onchange="GameUI.scratch.selectTicket(this.value)"
                                    class="w-full bg-slate-950 border border-slate-700 rounded-lg py-3 px-3 text-white text-sm">
                                    <option value="0">Penny Scratcher ($1)</option>
                                    <option value="1">Lucky 7s ($2)</option>
                                    <option value="2">Neon Nights ($5)</option>
                                    <option value="3">Golden Goose ($10)</option>
                                    <option value="4" selected>Diamond Hands ($20)</option>
                                    <option value="5">Ruby Red ($50)</option>
                                    <option value="6">Sapphire Sky ($100)</option>
                                    <option value="7">Emerald City ($250)</option>
                                    <option value="8">Platinum VIP ($500)</option>
                                    <option value="9">The Jackpot ($1000)</option>
                                </select>
                            </div>

                            <!-- Ticket Info Preview -->
                            <div class="bg-slate-950 p-4 rounded-lg border border-slate-800 mb-4 text-center">
                                <div id="scratch-info-name" class="font-bold text-white mb-1">Diamond Hands</div>
                                <div class="text-xs text-slate-500 mb-2">Max Prize</div>
                                <div id="scratch-info-prize" class="text-xl font-bold text-yellow-400 font-mono">
                                    $1,500.00</div>
                            </div>

                            <button id="scratch-btn-buy" onclick="GameUI.scratch.buyTicket()"
                                class="w-full bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 text-white font-bold py-4 rounded-lg shadow-lg active:scale-95 transition-transform flex items-center justify-center gap-2">
                                <span>BUY TICKET</span>
                                <span id="scratch-buy-price"
                                    class="bg-black/20 px-2 py-0.5 rounded text-xs">$20.00</span>
                            </button>

                            <p class="text-[10px] text-center text-slate-500 mt-4">
                                Drag over the ticket to scratch with your coin.
                            </p>
                        </div>

                        <!-- STATS INFO -->
                        <div id="controls-stats"
                            class="hidden-panel bg-slate-900 p-4 rounded-xl border border-slate-800 shadow-xl">
                            <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">üìà Balance History
                            </h2>
                            <p class="text-xs text-slate-400 mb-4">
                                Visualizing the trajectory of the simulation. Observe how variance interacts with
                                expected value over time.
                            </p>
                            <div class="p-3 bg-slate-950 rounded border border-slate-700 mb-4">
                                <div class="text-[10px] text-slate-500 uppercase">Data Points</div>
                                <div id="stats-count" class="font-mono text-white text-lg">0</div>
                            </div>
                            <div class="p-3 bg-slate-950 rounded border border-slate-700">
                                <div class="text-[10px] text-slate-500 uppercase">Peak Balance</div>
                                <div id="stats-peak" class="font-mono text-emerald-400 text-lg">0.00</div>
                            </div>
                        </div>

                        <!-- Stats Panel -->
                        <div class="bg-slate-900 p-4 rounded-xl border border-slate-800">
                            <h3 class="text-xs font-semibold text-slate-500 uppercase mb-3">Session Stats</h3>
                            <div class="space-y-2 text-sm">
                                <div class="flex justify-between">
                                    <span class="text-slate-400">Played</span>
                                    <span id="stat-balls" class="text-white font-mono">0</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-slate-400">P/L</span>
                                    <span id="stat-profit" class="text-emerald-400 font-mono">+0.00</span>
                                </div>
                                <!-- NEW REFILLS STAT -->
                                <div class="flex justify-between">
                                    <span class="text-slate-400">Refills</span>
                                    <span id="stat-refills" class="text-blue-400 font-mono">0</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Visualizer (Order 1 on Mobile) -->
                    <div class="lg:col-span-3 order-1 lg:order-2">
                        <div id="visualizer-plinko" class="game-canvas-wrapper">
                            <canvas id="plinko-canvas"></canvas>
                        </div>
                        <div id="visualizer-roulette" class="game-canvas-wrapper hidden-panel">
                            <canvas id="roulette-canvas"></canvas>
                        </div>
                        <div id="visualizer-slots" class="game-canvas-wrapper hidden-panel">
                            <canvas id="slots-canvas"></canvas>
                        </div>
                        <div id="visualizer-dice" class="game-canvas-wrapper hidden-panel">
                            <canvas id="dice-canvas"></canvas>
                        </div>
                        <div id="visualizer-blackjack" class="game-canvas-wrapper hidden-panel">
                            <canvas id="blackjack-canvas"></canvas>
                        </div>
                        <div id="visualizer-mines"
                            class="game-canvas-wrapper hidden-panel flex items-center justify-center">
                            <div id="mines-board" class="mines-grid"></div>
                        </div>
                        <div id="visualizer-rocket" class="game-canvas-wrapper hidden-panel">
                            <canvas id="rocket-canvas"></canvas>
                        </div>
                        <div id="visualizer-cases" class="game-canvas-wrapper hidden-panel">
                            <canvas id="cases-canvas"></canvas>
                        </div>
                        <div id="visualizer-poker" class="game-canvas-wrapper hidden-panel">
                            <canvas id="poker-canvas"></canvas>
                        </div>
                        <div id="visualizer-scratch"
                            class="game-canvas-wrapper hidden-panel relative bg-slate-800 flex items-center justify-center p-4">
                            <!-- This container holds the scratch layers -->
                            <div id="scratch-area"
                                class="relative w-full max-w-sm aspect-[3/4] shadow-2xl rounded-xl overflow-hidden transition-all duration-300">
                                <!-- The "Result" Layer (Underneath) -->
                                <div id="scratch-result-layer"
                                    class="absolute inset-0 bg-white flex flex-col items-center justify-center text-center p-6 z-0">
                                    <div class="text-slate-900 font-black text-2xl mb-2">WINNER?</div>
                                    <div id="scratch-outcome-display"
                                        class="text-4xl font-black text-slate-400 my-4 transform rotate-[-5deg]">???
                                    </div>
                                    <div class="text-xs text-slate-500 uppercase tracking-widest mt-auto">Code: <span
                                            id="scratch-code">---</span></div>
                                </div>
                                <!-- The Canvas Layer (The Foil) -->
                                <canvas id="scratch-canvas"
                                    class="absolute inset-0 z-10 touch-none cursor-crosshair"></canvas>
                            </div>
                        </div>
                        <div id="visualizer-stats" class="game-canvas-wrapper hidden-panel">
                            <canvas id="stats-canvas"></canvas>
                        </div>
                        <div class="mt-2 text-center text-[10px] text-slate-500">
                            Physics visualization rendered in HTML5 Canvas
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- UPDATE LOG MODAL -->
    <div id="updates-modal"
        class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
        <div
            class="bg-slate-900 border border-slate-700 w-full max-w-2xl rounded-2xl shadow-2xl flex flex-col max-h-[85vh]">
            <div class="p-6 border-b border-slate-800 flex justify-between items-center bg-slate-950/50 rounded-t-2xl">
                <div class="flex items-center gap-3">
                    <span class="text-2xl">üìú</span>
                    <div>
                        <h2 class="text-xl font-bold text-white">Update Log</h2>
                        <div class="text-xs text-slate-400">Recent changes and improvements</div>
                    </div>
                </div>
                <button onclick="GameUI.toggleUpdates()"
                    class="p-2 hover:bg-slate-800 rounded-lg text-slate-400 hover:text-white transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>

            <div id="updates-content" class="p-6 overflow-y-auto space-y-8">
                <!-- Updates injected here -->
            </div>

            <div class="p-4 border-t border-slate-800 bg-slate-950/30 rounded-b-2xl text-center">
                <button onclick="GameUI.toggleUpdates()"
                    class="px-6 py-2 bg-slate-800 hover:bg-slate-700 text-white font-bold rounded-lg transition">Close
                    Log</button>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script>
        /* ========================================== */
        /* LOGIC                                      */
        /* ========================================== */

        const GameConfig = {
            startCredits: 1000,
            credits: 1000,
            stats: { games: 0, startBalance: 0, refills: 0 },
            history: [], // For graph: [{i: 0, bal: 1000}]

            init() {
                // LOAD FROM LOCAL STORAGE (Persistent Save)
                let savedData = localStorage.getItem('simcade_save_v2');

                // Fallback: Cookies
                if (!savedData) {
                    const cookieData = this.getCookie('simcade_save_backup');
                    if (cookieData) {
                        try {
                            // Validate it looks like JSON
                            if (cookieData.startsWith('{')) savedData = cookieData;
                        } catch (e) {
                            console.log("Cookie data invalid");
                        }
                    } else {
                        console.log("No saved data found");
                    }
                }

                if (savedData) {
                    try {
                        const parsed = JSON.parse(savedData);
                        this.credits = parsed.credits;
                        this.stats.games = parsed.games || 0;
                        this.stats.startBalance = parsed.startBalance || 1000;
                        this.stats.refills = parsed.refills || 0;
                        this.history = parsed.history || [{ i: 0, bal: 1000 }];
                    } catch (e) {
                        console.error("Save file corrupted, resetting.");
                        this.credits = 1000;
                        this.history = [{ i: 0, bal: 1000 }];
                    }
                } else {
                    this.credits = 1000;
                    this.stats.startBalance = 1000;
                    this.history = [{ i: 0, bal: 1000 }];
                }
                this.updateDisplay();
            },

            save() {
                console.log("Saving game state...");
                // 1. Local Storage (Full Data)
                const data = {
                    credits: this.credits,
                    games: this.stats.games,
                    startBalance: this.stats.startBalance,
                    refills: this.stats.refills,
                    history: this.history
                };
                const str = JSON.stringify(data);
                localStorage.setItem('simcade_save_v2', str);

                // 2. Cookie Backup (Essential Data Only to save space)
                // Cookies have 4KB limit. We drop history to be safe.
                const backupData = {
                    credits: this.credits,
                    games: this.stats.games,
                    startBalance: this.stats.startBalance,
                    refills: this.stats.refills
                    // History omitted
                };
                this.setCookie('simcade_save_backup', JSON.stringify(backupData), 365);
            },

            // --- Cookie Helpers ---
            setCookie(name, value, days) {
                let expires = "";
                if (days) {
                    const date = new Date();
                    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                    expires = "; expires=" + date.toUTCString();
                }
                // FIX: Google Sites runs in an iframe, so we need SameSite=None; Secure
                document.cookie = name + "=" + (value || "") + expires + "; path=/; SameSite=None; Secure";
            },

            getCookie(name) {
                const nameEQ = name + "=";
                const ca = document.cookie.split(';');
                for (let i = 0; i < ca.length; i++) {
                    let c = ca[i];
                    while (c.charAt(0) == ' ') c = c.substring(1, c.length);
                    if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
                }
                return null;
            },

            // --- Manual Backup Logic ---
            openBackupModal() {
                const modal = document.getElementById('backup-modal');
                const field = document.getElementById('backup-export-field');

                // create export string (Base64)
                const data = {
                    credits: this.credits,
                    games: this.stats.games,
                    startBalance: this.stats.startBalance,
                    refills: this.stats.refills,
                    history: this.history
                };
                const str = btoa(JSON.stringify(data));
                field.value = str;

                modal.classList.remove('hidden');
            },

            copySave() {
                const field = document.getElementById('backup-export-field');
                field.select();
                document.execCommand('copy'); // Legacy but reliable
                // Visual feedback
                const btn = event.target;
                const original = btn.innerText;
                btn.innerText = "Copied!";
                setTimeout(() => btn.innerText = original, 1000);
            },

            importSave() {
                const field = document.getElementById('backup-import-field');
                const str = field.value.trim();

                console.log(str);

                if (!str) return;

                try {
                    const json = atob(str);
                    const parsed = JSON.parse(json);

                    // Validate basic integrity
                    if (typeof parsed.credits !== 'number') throw new Error("Invalid Save");

                    this.credits = parsed.credits;
                    this.stats.games = parsed.games || 0;
                    this.stats.startBalance = parsed.startBalance || 1000;
                    this.stats.refills = parsed.refills || 0;
                    this.history = parsed.history || [];

                    this.save(); // Save immediately
                    this.updateDisplay();

                    document.getElementById('backup-modal').classList.add('hidden');

                } catch (e) {
                    console.log(e);
                }
            },

            claimFreeCredits() {
                this.credits += 1000;
                this.stats.startBalance += 1000; // Increase start to keep P/L neutral to the refill
                this.stats.refills++;
                this.recordHistory();
                this.updateDisplay();
            },

            recordHistory() {
                // Push current state to history
                // Limit history size if needed (e.g. 5000 pts)
                if (this.history.length > 5000) this.history.shift();
                this.history.push({ i: this.stats.games, bal: this.credits });
            },

            updateDisplay() {
                const el = document.getElementById('credit-display');
                if (el) el.textContent = this.credits.toFixed(2);

                const profit = this.credits - this.stats.startBalance;
                const profitEl = document.getElementById('stat-profit');
                const gamesEl = document.getElementById('stat-balls');
                const refillsEl = document.getElementById('stat-refills');

                if (gamesEl) gamesEl.textContent = this.stats.games;
                if (refillsEl) refillsEl.textContent = this.stats.refills;

                if (profitEl) {
                    profitEl.textContent = (profit >= 0 ? '+' : '') + profit.toFixed(2);
                    profitEl.className = `font-mono ${profit >= 0 ? 'text-emerald-400' : 'text-red-400'}`;
                }
                this.save();

                // Update graph info if visible
                if (document.getElementById('stats-count')) {
                    document.getElementById('stats-count').innerText = this.history.length;
                    const peak = Math.max(...this.history.map(h => h.bal));
                    document.getElementById('stats-peak').innerText = peak.toFixed(2);
                }
            },

            deduct(amount) {
                if (this.credits >= amount) {
                    this.credits -= amount;
                    this.stats.games++;
                    this.updateDisplay(); // Save implicit
                    return true;
                }
                return false;
            },

            add(amount) {
                this.credits += amount;
                this.recordHistory(); // Record outcome
                this.updateDisplay();
            },

            resetCredits() {
                // Smart Reset: Reset money to 1000, keep stats/history
                const oldCredits = this.credits;
                this.credits = 1000;

                // Adjust startBalance so P/L remains accurate
                // New P/L should = Old P/L
                // (1000 - NewStart) = (OldCredits - OldStart)
                // NewStart = 1000 - (OldCredits - OldStart)
                this.stats.startBalance = 1000 - (oldCredits - this.stats.startBalance);

                this.stats.refills++; // Count as a "refill event" basically
                this.recordHistory();
                this.updateDisplay();
            }
        };

        // --- PLINKO ---
        class PlinkoGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.pegs = [];
                this.balls = [];
                this.multipliers = [];
                this.gravity = 0.25;
                this.pegRadius = 4;
                this.ballRadius = 7;
                this.scale = 1; // Default scale
                this.rows = 13;

                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.animate();
            }

            resize() {
                if (!this.canvas.offsetParent) return;
                this.width = this.canvas.parentElement.clientWidth;
                this.height = this.canvas.parentElement.clientHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.setupBoard();
            }

            setConfiguration(rows) {
                this.rows = parseInt(rows);
                this.setupBoard();
            }

            setupBoard() {
                this.pegs = [];
                this.multipliers = [];

                // 1. RESPONSIVE GRID CALCULATION
                // We need to fit the board vertically and horizontally.
                // Available Height (approx): Height - 60px (padding)
                // Total Board Height Units ~= (Rows * 0.9) + 1 (for buckets)
                const availableH = this.height - 60;
                const verticalUnits = (this.rows * 0.9) + 1;
                const maxGapHeight = availableH / verticalUnits;

                // Width constraint
                const maxGapWidth = this.width / (this.rows + 2);

                // Choose smallest constraint to ensure fit
                let gap = Math.min(maxGapHeight, maxGapWidth, 50);

                // 2. DYNAMIC SCALING
                // Scale elements based on gap size so they don't look crowded
                // Base gap 40px -> Scale 1.0
                const baseGap = 40;
                this.scale = Math.max(gap / baseGap, 0.55); // Minimum scale 0.55

                this.pegRadius = 4 * this.scale;
                this.ballRadius = 7 * this.scale;

                // 3. CENTERING
                const totalBoardHeight = ((this.rows - 1) * gap * 0.9) + gap + 30; // 30 is base multiplier height
                const startY = (this.height - totalBoardHeight) / 2 + 10;

                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col <= row; col++) {
                        const x = (this.width / 2) - (row * gap / 2) + (col * gap);
                        const y = startY + (row * gap * 0.9);
                        this.pegs.push({ x, y });
                    }
                }

                const mults = this.getMultipliers(this.rows);
                const bucketY = startY + ((this.rows - 1) * gap * 0.9) + gap;
                const totalWidth = (this.rows) * gap;
                const startX = (this.width / 2) - (totalWidth / 2);

                // Adjust multiplier width based on gap
                const multWidth = gap - (4 * this.scale);

                for (let i = 0; i < this.rows + 1; i++) {
                    this.multipliers.push({
                        x: startX + (i * gap) - (gap / 2),
                        y: bucketY,
                        w: gap - (4 * this.scale),
                        h: 30, // Keep text height readable
                        value: mults[i],
                        color: this.getMultiplierColor(mults[i])
                    });
                }

                // Store startY for dropping balls correctly
                this.boardStartY = startY;
            }

            getMultipliers(rows) {
                if (rows === 17) return [1000, 130, 26, 9, 4, 21, 0.5, 0.2, 0.2, 0.2, 0.2, 0.5, 2, 4, 9, 26, 130, 1000];
                if (rows === 9) return [29, 4, 2, 0.5, 0.2, 0.2, 0.5, 2, 4, 29];
                return [170, 26, 9, 3, 1, 0.5, 0.2, 0.2, 0.5, 1, 3, 9, 26, 170];
            }

            getMultiplierColor(val) {
                if (val < 1) return '#334155';
                if (val < 2) return '#f59e0b';
                if (val < 10) return '#ea580c';
                if (val < 50) return '#dc2626';
                return '#9333ea';
            }

            dropBall(betAmount) {
                // Drop from just above the first peg
                const dropY = this.boardStartY ? this.boardStartY - 20 : 30;

                this.balls.push({
                    x: this.width / 2,
                    y: dropY,
                    vx: 0,
                    vy: 0,
                    radius: this.ballRadius,
                    bet: betAmount,
                    active: true,
                    lastPegId: -1
                });
            }

            update() {
                this.balls.forEach(b => {
                    if (!b.active) return;
                    b.vy += this.gravity;
                    b.x += b.vx;
                    b.y += b.vy;

                    for (let i = 0; i < this.pegs.length; i++) {
                        let p = this.pegs[i];
                        let dx = b.x - p.x;
                        let dy = b.y - p.y;
                        let dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < b.radius + this.pegRadius) {
                            if (b.lastPegId !== i && dy < 0) {
                                const dir = Math.random() < 0.5 ? -1 : 1;
                                b.vx = dir * 1.5;
                                b.vy *= 0.5;
                                b.x = p.x + (dir * 5);
                                b.lastPegId = i;
                            } else if (b.lastPegId !== i) {
                                b.vx = dx * 0.5;
                            }
                        }
                    }

                    if (this.multipliers.length > 0 && b.y > this.multipliers[0].y - 10) {
                        for (let m of this.multipliers) {
                            if (b.x > m.x && b.x < m.x + m.w) {
                                b.active = false;
                                GameConfig.add(b.bet * m.value);
                                m.hit = Date.now();
                                break;
                            }
                        }
                        if (b.y > this.height) b.active = false;
                    }
                });
                this.balls = this.balls.filter(b => b.active);
            }

            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                this.pegs.forEach(p => {
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, this.pegRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                this.multipliers.forEach(m => {
                    const isHit = m.hit && Date.now() - m.hit < 200;
                    this.ctx.fillStyle = isHit ? '#fff' : m.color;
                    this.roundRect(this.ctx, m.x, m.y + (isHit ? 5 : 0), m.w, m.h, 4, true);
                    this.ctx.fillStyle = isHit ? '#000' : 'rgba(255,255,255,0.8)';
                    // Scale font size slightly
                    const fontSize = Math.max(10 * this.scale, 8);
                    this.ctx.font = `bold ${fontSize}px Inter`;
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(`${m.value}x`, m.x + m.w / 2, m.y + 18 + (isHit ? 5 : 0));
                });

                this.ctx.fillStyle = '#ef4444';
                this.balls.forEach(b => {
                    this.ctx.beginPath();
                    this.ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }

            roundRect(ctx, x, y, w, h, r, fill) {
                ctx.beginPath();
                ctx.roundRect(x, y, w, h, r);
                if (fill) ctx.fill();
            }
        }

        // --- ROULETTE (NEW) ---
        class RouletteGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                // American Roulette Sequence
                this.numbers = [0, 28, 9, 26, 30, 11, 7, 20, 32, 17, 5, 22, 34, 15, 3, 24, 36, 13, 1, '00', 27, 10, 25, 29, 12, 8, 19, 31, 18, 6, 21, 33, 16, 4, 23, 35, 14, 2];
                // 0 and 00 are Green. Others defined by index logic or explicit list.
                // Red numbers: 1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36
                this.reds = new Set([1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36]);

                this.angle = 0;
                this.velocity = 0;
                this.spinning = false;
                this.result = null;
                this.betType = null;
                this.betValue = null;
                this.betAmount = 0;
                this.radius = 200;

                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.animate();
            }

            resize() {
                if (!this.canvas.offsetParent) return;
                this.width = this.canvas.parentElement.clientWidth;
                this.height = this.canvas.parentElement.clientHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.radius = Math.min(this.width, this.height) * 0.4;
            }

            spin(betType, betValue, betAmount) {
                if (this.spinning) return;

                this.betType = betType;
                this.betValue = betValue;
                this.betAmount = betAmount;
                this.spinning = true;

                // Random Spin Duration and Force
                this.velocity = 0.5 + Math.random() * 0.3; // Initial speed
                this.friction = 0.003; // Slowdown rate

                document.getElementById('roulette-result').innerText = "Spinning...";
                document.getElementById('roulette-result').className = "text-sm font-bold h-6 text-yellow-400";
            }

            checkWin(winningNumber) {
                let won = false;
                const isRed = this.reds.has(typeof winningNumber === 'number' ? winningNumber : -1);
                const isZero = winningNumber === 0 || winningNumber === '00';
                const isBlack = !isRed && !isZero;
                const numVal = typeof winningNumber === 'number' ? winningNumber : -1;
                const isEven = numVal !== -1 && numVal !== 0 && numVal % 2 === 0;
                const isOdd = numVal !== -1 && numVal % 2 !== 0;

                if (this.betType === 'red' && isRed) won = true;
                else if (this.betType === 'black' && isBlack) won = true;
                else if (this.betType === 'even' && isEven) won = true;
                else if (this.betType === 'odd' && isOdd) won = true;
                else if (this.betType === '0' && winningNumber === 0) won = true;
                else if (this.betType === '00' && winningNumber === '00') won = true;
                else if (this.betType === 'number' && parseInt(this.betValue) === winningNumber) won = true;

                const resultEl = document.getElementById('roulette-result');

                if (won) {
                    let mult = 2;
                    if (this.betType === '0' || this.betType === '00' || this.betType === 'number') mult = 35;

                    const winAmt = this.betAmount * mult;
                    GameConfig.add(winAmt);
                    resultEl.innerText = `${winningNumber} - WIN! +${winAmt.toFixed(2)}`;
                    resultEl.className = "text-sm font-bold h-6 text-emerald-400 neon-text";
                } else {
                    GameConfig.recordHistory();
                    resultEl.innerText = `${winningNumber} - LOSS`;
                    resultEl.className = "text-sm font-bold h-6 text-red-400";
                }
            }

            update() {
                if (this.spinning) {
                    this.angle += this.velocity;
                    this.velocity *= 0.99; // Drag

                    if (this.velocity < 0.002) {
                        this.spinning = false;
                        this.velocity = 0;

                        // Calculate Result
                        // Pointer is at top (270 degrees or -PI/2 visually, but logic usually 0)
                        // Let's normalize angle to 0-2PI
                        const totalWedges = 38;
                        const arc = (Math.PI * 2) / totalWedges;

                        // Current rotation
                        let currentRot = this.angle % (Math.PI * 2);
                        if (currentRot < 0) currentRot += Math.PI * 2;

                        // The wheel rotates clockwise. The pointer is fixed at the top.
                        // So the index we land on is based on how much we rotated 'past' the start.
                        // Adjust for top position (which is -PI/2 relative to standard 0 at right)
                        const index = Math.floor(((Math.PI * 2) - currentRot + (Math.PI / 2) + (arc / 2)) % (Math.PI * 2) / arc);

                        const winningNumber = this.numbers[index % totalWedges];
                        this.checkWin(winningNumber);
                    }
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);

                const cx = this.width / 2;
                const cy = this.height / 2;
                const totalWedges = 38;
                const arc = (Math.PI * 2) / totalWedges;

                this.ctx.save();
                this.ctx.translate(cx, cy);
                this.ctx.rotate(this.angle);

                // Draw Wedges
                for (let i = 0; i < totalWedges; i++) {
                    const angle = i * arc;
                    const num = this.numbers[i];

                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 0);
                    this.ctx.arc(0, 0, this.radius, angle, angle + arc);

                    // Color
                    if (num === 0 || num === '00') this.ctx.fillStyle = '#059669'; // Green
                    else if (this.reds.has(num)) this.ctx.fillStyle = '#dc2626'; // Red
                    else this.ctx.fillStyle = '#1e293b'; // Black (Slate-800)

                    this.ctx.fill();
                    this.ctx.stroke();

                    // Text
                    this.ctx.save();
                    this.ctx.rotate(angle + arc / 2);
                    this.ctx.textAlign = "right";
                    this.ctx.fillStyle = "#fff";
                    this.ctx.font = "bold 14px Inter";
                    this.ctx.fillText(num, this.radius - 10, 5);
                    this.ctx.restore();
                }

                // Inner decorations
                this.ctx.beginPath();
                this.ctx.arc(0, 0, this.radius * 0.7, 0, Math.PI * 2);
                this.ctx.strokeStyle = "rgba(255,255,255,0.1)";
                this.ctx.stroke();

                this.ctx.restore();

                // Draw Center Cap
                this.ctx.beginPath();
                this.ctx.arc(cx, cy, 30, 0, Math.PI * 2);
                this.ctx.fillStyle = "#334155";
                this.ctx.fill();
                this.ctx.strokeStyle = "#cbd5e1";
                this.ctx.lineWidth = 4;
                this.ctx.stroke();

                // Draw Pointer (Triangle at Top)
                this.ctx.fillStyle = "#facc15"; // Yellow
                this.ctx.beginPath();
                this.ctx.moveTo(cx, cy - this.radius + 10);
                this.ctx.lineTo(cx - 10, cy - this.radius - 10);
                this.ctx.lineTo(cx + 10, cy - this.radius - 10);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = "#facc15";
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
            }

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        // --- SLOTS (NEW) ---
        class SlotsGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.reelCount = 3;
                // Symbols: Cherry, Lemon, Grape, Bell, Diamond, 7, Bar
                this.symbols = ['üçí', 'üçã', 'üçá', 'üîî', 'üíé', '7Ô∏è‚É£'];
                this.reelState = []; // [{currentSym: 'üçí', targetSym: '7Ô∏è‚É£', offset: 0, spinning: false, stopping: false}]
                this.isSpinning = false;
                this.bet = 10;

                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.initReels();
                // Particles
                this.particles = [];

                this.animate();
            }

            spawnConfetti(amount, x, y) {
                const colors = ['#facc15', '#ef4444', '#3b82f6', '#22c55e', '#a855f7', '#ffffff'];
                for (let i = 0; i < amount; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 12,
                        vy: (Math.random() - 1) * 12, // Explode UP
                        size: Math.random() * 8 + 4,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        rotation: Math.random() * 360,
                        rSpeed: (Math.random() - 0.5) * 10,
                        life: 1.0,
                        decay: Math.random() * 0.01 + 0.005,
                        gravity: 0.2
                    });
                }
            }

            drawParticles() {
                if (this.particles.length === 0) return;
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += p.gravity;
                    p.rotation += p.rSpeed;
                    p.life -= p.decay;

                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                        continue;
                    }

                    this.ctx.save();
                    this.ctx.translate(p.x, p.y);
                    this.ctx.rotate(p.rotation * Math.PI / 180);
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.life;
                    this.ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    this.ctx.restore();
                }
            }

            setMode(n) {
                if (this.isSpinning) return;
                this.reelCount = n;
                // Update buttons UI
                [3, 4, 5].forEach(i => {
                    const btn = document.getElementById(`slots-mode-${i}`);
                    if (i === n) btn.className = 'bg-blue-600 text-white p-2 rounded text-xs font-bold border border-transparent';
                    else btn.className = 'bg-slate-800 text-slate-400 p-2 rounded text-xs font-bold border border-slate-700';
                });
                this.initReels();
            }

            resize() {
                if (!this.canvas.offsetParent) return;
                this.width = this.canvas.parentElement.clientWidth;
                this.height = this.canvas.parentElement.clientHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
            }

            initReels() {
                this.reelState = [];
                for (let i = 0; i < this.reelCount; i++) {
                    const rand = this.symbols[Math.floor(Math.random() * this.symbols.length)];
                    this.reelState.push({
                        currentSym: rand,
                        targetSym: null,
                        yOffset: 0,
                        speed: 0,
                        state: 'idle', // idle, spin, stopping
                        stopDelay: 0
                    });
                }
            }

            spin() {
                if (this.isSpinning) return;
                const betInput = document.getElementById('bet-input-slots');
                const bet = parseFloat(betInput.value);
                if (!GameUI.validateBet(bet)) return;

                this.bet = bet;
                this.isSpinning = true;
                document.getElementById('slots-result').innerText = "Spinning...";
                document.getElementById('slots-result').className = "text-sm font-bold h-6 text-yellow-400";

                const targets = [];
                const rTier = Math.random();
                let matchCount = 0;

                // --- MODE SPECIFIC LOGIC ---
                if (this.reelCount === 3) {
                    // MODE 3: Classic (High Volatility)
                    // Simple Win or Loss. No "partial" matches.
                    // Hit Rate: 12% (Significantly reduced for House Edge)
                    if (rTier < 0.12) matchCount = 3;
                    else matchCount = 0;

                } else if (this.reelCount === 4) {
                    // MODE 4: Selected (Balanced)
                    // 4-Match: 4%
                    // 3-Match: 25%
                    if (rTier < 0.04) matchCount = 4;
                    else if (rTier < 0.29) matchCount = 3;
                    else matchCount = 0;

                } else {
                    // MODE 5: Grinder (High Frequency)
                    // 5-Match: 0.5%
                    // 4-Match: 2.0% (Reduced from 3%)
                    // 3-Match: 20.0% (Reduced from 25%)
                    if (rTier < 0.005) matchCount = 5;
                    else if (rTier < 0.025) matchCount = 4;
                    else if (rTier < 0.225) matchCount = 3;
                    else matchCount = 0;
                }

                // Determine Symbol
                let winSym = 'üçí';
                const rSym = Math.random();
                // Universal Symbol Weights
                if (rSym < 0.005) winSym = '7Ô∏è‚É£';
                else if (rSym < 0.025) winSym = 'üíé';
                else if (rSym < 0.060) winSym = 'üîî';
                else if (rSym < 0.150) winSym = 'üçá';
                else if (rSym < 0.400) winSym = 'üçã';
                else winSym = 'üçí';

                // Populate Targets
                for (let i = 0; i < matchCount; i++) targets.push(winSym);

                // Fill remaining with random junk
                for (let i = matchCount; i < this.reelCount; i++) {
                    let junk;
                    do {
                        junk = this.symbols[Math.floor(Math.random() * this.symbols.length)];
                    } while (junk === winSym);
                    targets.push(junk);
                }

                // Start Reels
                this.reelState.forEach((reel, i) => {
                    reel.state = 'spin';
                    reel.targetSym = targets[i];
                    reel.speed = 0;
                    reel.stopDelay = 60 + (i * 30);
                });
            }

            checkWin() {
                // Count consecutive matches from left
                const first = this.reelState[0].currentSym;
                let matches = 1;
                for (let i = 1; i < this.reelCount; i++) {
                    if (this.reelState[i].currentSym === first) matches++;
                    else break;
                }

                if (matches >= 3) {
                    let totalMult = 0;

                    // --- PAYOUT TABLE ---
                    if (this.reelCount === 3) {
                        // CLASSIC 3-REEL PAYOUTS (Always Profit)
                        if (first === 'üçí') totalMult = 3;    // Win 3x
                        else if (first === 'üçã') totalMult = 5;
                        else if (first === 'üçá') totalMult = 10;
                        else if (first === 'üîî') totalMult = 25;
                        else if (first === 'üíé') totalMult = 50;
                        else if (first === '7Ô∏è‚É£') totalMult = 100;
                    }
                    else if (this.reelCount === 4) {
                        // 4-REEL PAYOUTS
                        let base = 0;
                        if (first === 'üçí') base = 0.5; // Loss
                        else if (first === 'üçã') base = 1.0; // Breakeven
                        else base = 2.0; // Others start profitable

                        // Higher symbols
                        if (first === 'üçá') base = 2;
                        if (first === 'üîî') base = 5;
                        if (first === 'üíé') base = 10;
                        if (first === '7Ô∏è‚É£') base = 25;

                        if (matches === 3) totalMult = base;
                        if (matches === 4) totalMult = base * 5; // Big boost for 4
                    }
                    else {
                        // 5-REEL PAYOUTS
                        let base = 0;
                        // 3-Match Values
                        if (first === 'üçí') base = 0.2; // Hard Loss
                        else if (first === 'üçã') base = 1.2; // PROFIT (Requested)
                        else if (first === 'üçá') base = 1.5;
                        else base = 2.5;

                        // Rarity Boost
                        if (first === 'üîî') base = 5;
                        if (first === 'üíé') base = 15;
                        if (first === '7Ô∏è‚É£') base = 30;

                        if (matches === 3) totalMult = base;
                        if (matches === 4) totalMult = base * 4;
                        if (matches === 5) totalMult = base * 20; // JACKPOT
                    }

                    const win = this.bet * totalMult;
                    GameConfig.add(win);

                    // Visuals & Celebration
                    const netWin = win - this.bet;
                    const centerX = this.width / 2;
                    const centerY = this.height / 2;

                    if (netWin <= 0) {
                        // "False Win"
                        document.getElementById('slots-result').innerText = `${matches}x ${first} (Back: ${win.toFixed(2)})`;
                        document.getElementById('slots-result').className = "text-sm font-bold h-6 text-yellow-600";
                    } else {
                        // Real Win
                        document.getElementById('slots-result').innerText = `${matches}x ${first} WIN! +${win.toFixed(2)}`;
                        document.getElementById('slots-result').className = "text-sm font-bold h-6 text-emerald-400 neon-text";
                    }

                    console.log("Win: " + matches)
                    // ANIMATION LOGIC (Always trigger for any match now)
                    if (matches === 5) { // Or matches === reelCount for 5-reel? Let's stick to absolute
                        // HUGE JACKPOT
                        this.spawnConfetti(250, centerX, centerY);
                    } else if (matches === 4) {
                        // BIG WIN
                        this.spawnConfetti(80, centerX, centerY);
                    } else {
                        // 3-Match (Even false wins get a little pop now)
                        this.spawnConfetti(200, centerX, centerY);
                    }

                } else {
                    GameConfig.recordHistory();
                    document.getElementById('slots-result').innerText = "No Win";
                    document.getElementById('slots-result').className = "text-sm font-bold h-6 text-slate-500";
                }
                this.isSpinning = false;
            }

            drawParticles() {
                if (this.particles.length === 0) return;
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];

                    // Update P (Physics) inside Draw loop (like Blackjack)
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += p.gravity;
                    p.rotation += p.rSpeed;
                    p.life -= p.decay;

                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                        continue;
                    }

                    // Draw P
                    this.ctx.save();
                    this.ctx.translate(p.x, p.y);
                    this.ctx.rotate(p.rotation * Math.PI / 180);
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.life;
                    this.ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    this.ctx.restore();
                }
            }

            update() {
                let active = false;

                // Note: Particles are now updated in draw()

                this.reelState.forEach((reel, i) => {
                    if (reel.state === 'idle') return;
                    active = true;

                    // Accelerate
                    if (reel.state === 'spin') {
                        if (reel.speed < 40) reel.speed += 2;
                        reel.yOffset += reel.speed;

                        reel.stopDelay--;
                        if (reel.stopDelay <= 0) {
                            reel.state = 'stopping';
                        }
                    }

                    // Decelerate / Snap
                    if (reel.state === 'stopping') {
                        // Switch symbol to target if close to stop
                        reel.speed *= 0.8; // Slow down
                        reel.yOffset += reel.speed;

                        if (reel.speed < 2) {
                            reel.speed = 0;
                            reel.yOffset = 0;
                            reel.currentSym = reel.targetSym;
                            reel.state = 'idle';
                        }
                    }

                    // Wrap texture look
                    if (reel.yOffset > 100) reel.yOffset -= 100;
                });

                if (!active && this.isSpinning) {
                    // All stopped
                    this.checkWin();
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);

                const reelW = Math.min(100, (this.width - 40) / this.reelCount);
                const reelH = 150; // Visible window height
                const startX = (this.width - (this.reelCount * reelW) - ((this.reelCount - 1) * 10)) / 2;
                const centerY = this.height / 2;

                // Draw Machine Frame
                this.ctx.fillStyle = '#1e293b';
                this.ctx.strokeStyle = '#334155';
                this.ctx.lineWidth = 4;
                this.roundRect(this.ctx, startX - 20, centerY - reelH / 2 - 20, (this.reelCount * reelW) + ((this.reelCount - 1) * 10) + 40, reelH + 40, 10, true, true);

                // Draw Reels
                this.reelState.forEach((reel, i) => {
                    const x = startX + (i * (reelW + 10));
                    const y = centerY - reelH / 2;

                    // Clip Region for Reel
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.rect(x, y, reelW, reelH);
                    this.ctx.clip();

                    // Background
                    this.ctx.fillStyle = '#0f172a';
                    this.ctx.fillRect(x, y, reelW, reelH);
                    this.ctx.strokeStyle = '#000';
                    this.ctx.strokeRect(x, y, reelW, reelH);

                    // Draw Symbols
                    this.ctx.font = `${reelW * 0.6}px Inter`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';

                    if (reel.state !== 'idle') {
                        // Motion Blur Effect
                        this.ctx.filter = 'blur(4px)';
                        // Draw vertical strip
                        for (let k = -1; k < 2; k++) {
                            const sym = this.symbols[(k + 2) % this.symbols.length];
                            this.ctx.fillText(sym, x + reelW / 2, centerY + (k * 80) + (reel.yOffset % 80));
                        }
                        this.ctx.filter = 'none';
                    } else {
                        // Static
                        this.ctx.fillText(reel.currentSym, x + reelW / 2, centerY);

                        // Previous/Next hints (dimmed)
                        this.ctx.globalAlpha = 0.2;
                        this.ctx.font = `${reelW * 0.4}px Inter`;
                        this.ctx.fillText("‚ùì", x + reelW / 2, centerY - 80);
                        this.ctx.fillText("‚ùì", x + reelW / 2, centerY + 80);
                        this.ctx.globalAlpha = 1.0;
                    }

                    // Inner Shadow
                    this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    this.ctx.fillRect(x, y, reelW, 10); // Top shadow
                    this.ctx.fillRect(x, y + reelH - 10, reelW, 10); // Bottom shadow

                    this.ctx.restore();
                });

                // Payline Indicator
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(startX - 30, centerY);
                this.ctx.lineTo(startX - 10, centerY);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(startX + (this.reelCount * reelW) + ((this.reelCount - 1) * 10) + 10, centerY);
                this.ctx.lineTo(startX + (this.reelCount * reelW) + ((this.reelCount - 1) * 10) + 30, centerY);
                this.ctx.stroke();

                // Draw Particles on TOP
                this.drawParticles();
            }

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }

            roundRect(ctx, x, y, w, h, r, fill, stroke) {
                ctx.beginPath();
                ctx.roundRect(x, y, w, h, r);
                if (fill) ctx.fill();
                if (stroke) ctx.stroke();
            }
        }

        // --- DICE ---
        class DiceGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.dice = [{ val: 1 }, { val: 6 }];
                this.rolling = false;
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.animate();
            }
            resize() {
                if (!this.canvas.offsetParent) return;
                this.width = this.canvas.parentElement.clientWidth;
                this.height = this.canvas.parentElement.clientHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
            }
            roll(betAmount, type) {
                if (this.rolling) return;
                this.rolling = true;
                let frames = 0;
                const rollAnim = setInterval(() => {
                    this.dice[0].val = Math.floor(Math.random() * 6) + 1;
                    this.dice[1].val = Math.floor(Math.random() * 6) + 1;
                    frames++;
                    if (frames >= 40) {
                        clearInterval(rollAnim);
                        this.finishRoll(betAmount, type);
                    }
                }, 50);
            }
            finishRoll(betAmount, type) {
                this.rolling = false;
                const d1 = Math.floor(Math.random() * 6) + 1;
                const d2 = Math.floor(Math.random() * 6) + 1;
                this.dice[0].val = d1;
                this.dice[1].val = d2;
                const sum = d1 + d2;
                let winMultiplier = 0;
                if (type === 'under' && sum < 7) winMultiplier = 2.3;
                else if (type === 'exact' && sum === 7) winMultiplier = 5.8;
                else if (type === 'over' && sum > 7) winMultiplier = 2.3;

                if (winMultiplier > 0) GameConfig.add(betAmount * winMultiplier);
                else GameConfig.recordHistory(); // FIX: Record loss for graph
            }
            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                const dieSize = Math.min(100, this.width * 0.3); // Responsive dice size
                const gap = 40;
                const totalW = (dieSize * 2) + gap;
                const startX = (this.width - totalW) / 2;
                const startY = (this.height - dieSize) / 2;
                this.drawDie(startX, startY, dieSize, this.dice[0].val);
                this.drawDie(startX + dieSize + gap, startY, dieSize, this.dice[1].val);
                this.ctx.fillStyle = '#94a3b8';
                this.ctx.font = '16px Inter';
                this.ctx.textAlign = 'center';
                if (!this.rolling) {
                    const sum = this.dice[0].val + this.dice[1].val;
                    this.ctx.font = 'bold 24px Inter';
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillText(`Total: ${sum}`, this.width / 2, startY + dieSize + 50);
                }
            }
            drawDie(x, y, size, val) {
                this.ctx.fillStyle = '#fff';
                this.ctx.shadowBlur = 15;
                this.ctx.shadowColor = 'rgba(0,0,0,0.3)';
                this.ctx.beginPath();
                this.ctx.roundRect(x, y, size, size, 16);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                this.ctx.fillStyle = '#000';
                const pipSize = size / 5;
                const c = size / 2;
                const q = size / 4;
                const drawPip = (dx, dy) => {
                    this.ctx.beginPath();
                    this.ctx.arc(x + dx, y + dy, pipSize / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                };
                if (val % 2 === 1) drawPip(c, c);
                if (val > 1) { drawPip(q, q); drawPip(size - q, size - q); }
                if (val > 3) { drawPip(size - q, q); drawPip(q, size - q); }
                if (val === 6) { drawPip(q, c); drawPip(size - q, c); }
            }
            animate() { this.draw(); requestAnimationFrame(() => this.animate()); }
        }

        // --- BLACKJACK ---
        class BlackjackGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.deck = [];
                this.shoe = [];
                this.hands = []; // Array of hand objects: { cards:[], bet:0, done:false, status:'playing' }
                this.dealerHand = [];
                this.particles = [];
                this.activeHandIdx = 0;
                this.gameState = 'idle'; // idle, playing, dealerTurn, result
                this.message = "Place your bet";
                this.decks = 6;
                this.reshuffleThreshold = 0.2;
                this.initShoe();
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.animate();
            }
            resize() {
                if (!this.canvas.offsetParent) return;
                this.width = this.canvas.parentElement.clientWidth;
                this.height = this.canvas.parentElement.clientHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
            }
            initShoe() {
                this.shoe = [];
                const suits = ['‚ô†', '‚ô•', '‚ô£', '‚ô¶'];
                const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
                for (let d = 0; d < this.decks; d++) {
                    for (let s of suits) {
                        for (let v of values) {
                            let weight = parseInt(v);
                            if (v === 'J' || v === 'Q' || v === 'K') weight = 10;
                            if (v === 'A') weight = 11;
                            this.shoe.push({ suit: s, value: v, weight: weight });
                        }
                    }
                }
                this.shuffle(this.shoe);
            }
            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
            startHand(bet) {
                if (this.gameState !== 'idle' && this.gameState !== 'result') return;
                this.particles = [];
                if (this.shoe.length < (52 * this.decks * this.reshuffleThreshold)) this.initShoe();

                // Initialize Hands
                this.hands = [{ cards: [], bet: bet, done: false, status: 'playing' }];
                this.activeHandIdx = 0;
                this.dealerHand = [];
                this.gameState = 'playing';
                this.message = "";

                // Deal
                this.hands[0].cards.push(this.shoe.pop());
                this.dealerHand.push(this.shoe.pop());
                this.hands[0].cards.push(this.shoe.pop());
                this.dealerHand.push(this.shoe.pop());

                // Removed updateLabStats() call

                // Check initial BJ
                if (this.getHandValue(this.hands[0].cards) === 21) {
                    this.hands[0].done = true;
                    this.gameState = 'dealerTurn';
                    this.resolveGame();
                }
            }

            canSplit() {
                const hand = this.hands[this.activeHandIdx];
                if (!hand || this.hands.length > 1) return false; // Limit to 1 split for UI
                if (hand.cards.length !== 2) return false;
                // Strict Pair Rule: Must be same rank (e.g. J+J ok, J+Q no)
                return hand.cards[0].value === hand.cards[1].value;
            }

            canDouble() {
                const hand = this.hands[this.activeHandIdx];
                // Can only double on first 2 cards of a hand
                if (!hand || hand.cards.length !== 2) return false;
                // Must have enough credits
                return GameConfig.credits >= hand.bet;
            }

            split() {
                if (!this.canSplit()) return;
                const hand = this.hands[this.activeHandIdx];

                // Deduct second bet
                if (!GameConfig.deduct(hand.bet)) {
                    alert("Not enough credits to split!");
                    return;
                }

                // Create new hand
                const newHand = { cards: [hand.cards.pop()], bet: hand.bet, done: false, status: 'playing' };
                this.hands.push(newHand);

                // Deal second cards to both
                hand.cards.push(this.shoe.pop());
                newHand.cards.push(this.shoe.pop());

                // Refresh logic
                this.message = "Splitting...";
            }

            doubleDown() {
                if (!this.canDouble()) return;
                const hand = this.hands[this.activeHandIdx];

                // Deduct extra bet
                if (!GameConfig.deduct(hand.bet)) {
                    alert("Not enough credits to double!");
                    return;
                }

                hand.bet *= 2;
                hand.cards.push(this.shoe.pop()); // Deal exactly one card

                // Check bust
                if (this.getHandValue(hand.cards) > 21) {
                    hand.status = 'bust';
                    this.triggerBustAnimation();
                }

                // Removed updateLabStats() call
                // Double Down always ends the turn for this hand
                this.nextHand();
            }

            hit() {
                if (this.gameState !== 'playing') return;
                const hand = this.hands[this.activeHandIdx];
                hand.cards.push(this.shoe.pop());

                if (this.getHandValue(hand.cards) > 21) {
                    hand.status = 'bust';
                    this.triggerBustAnimation();
                    this.nextHand();
                }
                // Removed updateLabStats() call
            }

            stand() {
                if (this.gameState !== 'playing') return;
                this.nextHand();
            }

            nextHand() {
                this.hands[this.activeHandIdx].done = true;
                this.activeHandIdx++;

                if (this.activeHandIdx >= this.hands.length) {
                    this.gameState = 'dealerTurn';
                    this.playDealer();
                }
            }

            triggerBustAnimation() {
                for (let i = 0; i < 60; i++) {
                    this.particles.push({
                        x: Math.random() * this.width,
                        y: Math.random() * -100 - 20,
                        vx: (Math.random() - 0.5) * 4,
                        vy: Math.random() * 5 + 3,
                        size: Math.random() * 15 + 8,
                        rotation: Math.random() * 360,
                        rSpeed: (Math.random() - 0.5) * 10,
                        alpha: 1.0
                    });
                }
            }
            playDealer() {
                const loop = setInterval(() => {
                    let dVal = this.getHandValue(this.dealerHand);
                    if (dVal < 17) this.dealerHand.push(this.shoe.pop());
                    else {
                        clearInterval(loop);
                        this.resolveGame();
                    }
                }, 800);
            }
            spawnConfetti(amount, x, y) {
                const colors = ['#facc15', '#ef4444', '#3b82f6', '#22c55e', '#a855f7', '#ffffff'];
                for (let i = 0; i < amount; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 12,
                        vy: (Math.random() - 1) * 12, // Explode UP
                        size: Math.random() * 8 + 4,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        rotation: Math.random() * 360,
                        rSpeed: (Math.random() - 0.5) * 10,
                        life: 1.0,
                        decay: Math.random() * 0.01 + 0.005,
                        gravity: 0.2
                    });
                }
            }

            resolveGame() {
                this.gameState = 'result';
                const dVal = this.getHandValue(this.dealerHand);
                const dBJ = (dVal === 21 && this.dealerHand.length === 2);

                let results = [];
                let totalWin = 0;

                this.hands.forEach((hand, i) => {
                    const pVal = this.getHandValue(hand.cards);
                    const pBJ = (pVal === 21 && hand.cards.length === 2);
                    let res = "";

                    if (hand.status === 'bust') {
                        res = "BUST";
                    } else if (pBJ && !dBJ) {
                        res = "BLACKJACK!";
                        totalWin += hand.bet * 2.5; // 3:2 payout
                        // TRIGGER CELEBRATION
                        this.spawnConfetti(200, this.width / 2, this.height / 2);
                    } else if (dBJ && !pBJ) {
                        res = "LOSE";
                    } else if (dBJ && pBJ) {
                        res = "PUSH";
                        totalWin += hand.bet;
                    } else if (dVal > 21) {
                        res = "WIN";
                        totalWin += hand.bet * 2;
                    } else if (pVal > dVal) {
                        res = "WIN";
                        totalWin += hand.bet * 2;
                    } else if (pVal === dVal) {
                        res = "PUSH";
                        totalWin += hand.bet;
                    } else {
                        res = "LOSE";
                    }
                    results.push(`Hand ${i + 1}: ${res}`);
                });

                if (totalWin > 0) {
                    GameConfig.add(totalWin);
                    this.message = `WON +${totalWin.toFixed(2)}`;
                } else {
                    this.message = "DEALER WINS";
                    GameConfig.recordHistory();
                }
            }
            getHandValue(cards) {
                let val = 0; let aces = 0;
                for (let c of cards) { val += c.weight; if (c.value === 'A') aces++; }
                while (val > 21 && aces > 0) { val -= 10; aces--; }
                return val;
            }

            // Removed updateLabStats() and runDealerSim() methods entirely

            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                this.drawParticles();

                const cardW = Math.min(70, this.width * 0.15);
                const cardH = cardW * 1.4;
                const gap = 10;

                // Dealer
                this.ctx.fillStyle = '#94a3b8';
                this.ctx.font = '14px Inter';
                this.ctx.textAlign = 'center';
                this.ctx.fillText("DEALER", this.width / 2, this.height * 0.15);

                let startX = (this.width - ((this.dealerHand.length * (cardW + gap)) - gap)) / 2;
                this.dealerHand.forEach((card, i) => {
                    if (i === 1 && (this.gameState === 'playing' || this.gameState === 'idle'))
                        this.drawCardBack(startX + (i * (cardW + gap)), this.height * 0.2, cardW, cardH);
                    else
                        this.drawCardFace(card, startX + (i * (cardW + gap)), this.height * 0.2, cardW, cardH);
                });

                if (this.gameState === 'result' || this.gameState === 'dealerTurn') {
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillText(this.getHandValue(this.dealerHand), this.width / 2, this.height * 0.2 + cardH + 20);
                }

                // Player Hands
                this.hands.forEach((hand, hIdx) => {
                    // Calculate offset for split hands
                    // If 1 hand: Center
                    // If 2 hands: Left side / Right side
                    let centerX = this.width / 2;
                    if (this.hands.length > 1) {
                        centerX = (this.width / 2) + (hIdx === 0 ? -cardW * 1.5 : cardW * 1.5);
                    }

                    this.ctx.fillStyle = (hIdx === this.activeHandIdx && this.gameState === 'playing') ? '#fff' : '#64748b';
                    this.ctx.fillText(`HAND ${hIdx + 1}`, centerX, this.height * 0.55);

                    // Active Indicator
                    if (hIdx === this.activeHandIdx && this.gameState === 'playing') {
                        this.ctx.fillStyle = '#3b82f6';
                        this.ctx.font = '20px Inter';
                        this.ctx.fillText("‚¨áÔ∏è", centerX, this.height * 0.55 - 20);
                    }

                    let hStartX = centerX - ((hand.cards.length * (cardW + gap)) - gap) / 2;
                    hand.cards.forEach((card, i) => {
                        this.drawCardFace(card, hStartX + (i * (cardW + gap)), this.height * 0.6, cardW, cardH);
                    });

                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '14px Inter';
                    const val = this.getHandValue(hand.cards);
                    this.ctx.fillText(val, centerX, this.height * 0.6 + cardH + 20);
                });

                if (this.message) {
                    this.ctx.fillStyle = '#facc15';
                    this.ctx.font = 'bold 20px Inter';
                    this.ctx.fillText(this.message, this.width / 2, this.height - 20);
                }
            }
            drawParticles() {
                if (this.particles.length === 0) return;
                this.particles.forEach((p, i) => {
                    p.y += p.vy; p.x += p.vx; p.vy += 0.2; p.rotation += p.rSpeed; p.alpha -= 0.01;
                    if (p.alpha <= 0) { this.particles.splice(i, 1); return; }
                    this.ctx.save();
                    this.ctx.translate(p.x, p.y);
                    this.ctx.rotate(p.rotation * Math.PI / 180);
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha})`;
                    this.ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    this.ctx.restore();
                });
            }
            drawCardFace(card, x, y, w, h) {
                this.ctx.fillStyle = '#fff';
                this.ctx.shadowBlur = 5;
                this.ctx.shadowColor = 'rgba(0,0,0,0.3)';
                this.ctx.beginPath(); this.ctx.roundRect(x, y, w, h, 6); this.ctx.fill(); this.ctx.shadowBlur = 0;
                const color = (card.suit === '‚ô•' || card.suit === '‚ô¶') ? '#ef4444' : '#0f172a';
                this.ctx.fillStyle = color;
                this.ctx.font = `bold ${w / 4}px Inter`;
                this.ctx.textAlign = 'left'; this.ctx.fillText(card.value, x + 5, y + w / 3);
                this.ctx.font = `${w / 4}px Inter`;
                this.ctx.fillText(card.suit, x + 5, y + w / 1.5);
                this.ctx.textAlign = 'center'; this.ctx.font = `${w / 2}px Inter`;
                this.ctx.fillText(card.suit, x + w / 2, y + h / 2 + 5);
            }
            drawCardBack(x, y, w, h) {
                this.ctx.fillStyle = '#ef4444';
                this.ctx.beginPath(); this.ctx.roundRect(x, y, w, h, 6); this.ctx.fill();
                this.ctx.strokeStyle = '#b91c1c'; this.ctx.lineWidth = 2;
                this.ctx.beginPath(); this.ctx.moveTo(x, y); this.ctx.lineTo(x + w, y + h);
                this.ctx.moveTo(x + w, y); this.ctx.lineTo(x, y + h); this.ctx.stroke();
            }
            animate() { this.draw(); requestAnimationFrame(() => this.animate()); }
        }

        // --- MINES ---
        class MinesGame {
            constructor() {
                this.gridSize = 5;
                this.minesCount = 3;
                this.bet = 0;
                this.tiles = [];
                this.isPlaying = false;
                this.currentMultiplier = 1.0;
                this.safeRemaining = 0;
                this.totalRemaining = 0;
                this.updateGridConfig();

                // Validation Listeners
                const input = document.getElementById('mines-count-input');
                if (input) {
                    input.addEventListener('input', () => {
                        const max = (this.gridSize * this.gridSize) - 1;
                        let val = parseInt(input.value);
                        if (val > max) input.value = max;
                    });
                    input.addEventListener('change', () => {
                        const max = (this.gridSize * this.gridSize) - 1;
                        let val = parseInt(input.value);
                        if (isNaN(val) || val < 1) input.value = 1;
                        if (val > max) input.value = max;
                    });
                }
            }
            updateGridConfig() {
                if (this.isPlaying) return;
                const val = parseInt(document.getElementById('mines-grid-select').value);
                this.gridSize = val;
                const input = document.getElementById('mines-count-input');
                const max = (this.gridSize * this.gridSize) - 1;
                input.max = max;
                if (parseInt(input.value) > max) input.value = max;
                this.renderGrid(true);
            }
            startGame() {
                if (this.isPlaying) return;
                const betInput = document.getElementById('bet-input-mines');
                const minesInput = document.getElementById('mines-count-input');
                const bet = parseFloat(betInput.value);
                let mines = parseInt(minesInput.value);
                const maxMines = (this.gridSize * this.gridSize) - 1;
                if (mines > maxMines) mines = maxMines;
                if (mines < 1) mines = 1;

                if (!GameUI.validateBet(bet)) return;

                this.bet = bet;
                this.minesCount = mines;
                this.isPlaying = true;
                this.currentMultiplier = 1.0;
                this.totalRemaining = this.gridSize * this.gridSize;
                this.safeRemaining = this.totalRemaining - mines;
                this.tiles = Array(this.totalRemaining).fill().map(() => ({ isMine: false, revealed: false }));
                let placed = 0;
                while (placed < mines) {
                    const idx = Math.floor(Math.random() * this.totalRemaining);
                    if (!this.tiles[idx].isMine) { this.tiles[idx].isMine = true; placed++; }
                }

                document.getElementById('mines-btn-start').classList.add('hidden');
                document.getElementById('mines-btn-cashout').classList.remove('hidden');
                document.getElementById('mines-status').classList.remove('hidden');
                document.getElementById('mines-grid-select').disabled = true;
                document.getElementById('mines-count-input').disabled = true;
                this.updateStatus();
                this.renderGrid(false);
            }
            clickTile(index) {
                if (!this.isPlaying) return;
                const tile = this.tiles[index];
                if (tile.revealed) return;
                tile.revealed = true;
                const el = document.getElementById(`mine-tile-${index}`);
                el.classList.add('revealed');
                if (tile.isMine) {
                    el.classList.add('bomb'); el.innerHTML = "üí£";
                    this.gameOver(false);
                } else {
                    el.innerHTML = "<span class='animate-gem'>üíé</span>"; el.classList.add('gem');
                    const prob = this.safeRemaining / this.totalRemaining;
                    this.currentMultiplier = (this.currentMultiplier * (1 / prob)) * 0.97;
                    this.safeRemaining--; this.totalRemaining--;
                    this.updateStatus();
                }
            }
            cashout() {
                if (!this.isPlaying) return;
                GameConfig.add(this.bet * this.currentMultiplier);
                this.gameOver(true);
            }
            gameOver(won) {
                this.isPlaying = false;
                this.tiles.forEach((t, i) => {
                    if (t.isMine) {
                        const el = document.getElementById(`mine-tile-${i}`);
                        el.classList.add('revealed');
                        if (!el.classList.contains('bomb')) { el.innerHTML = "üí£"; el.style.opacity = "0.5"; }
                    }
                });
                document.getElementById('mines-btn-start').classList.remove('hidden');
                document.getElementById('mines-btn-cashout').classList.add('hidden');
                document.getElementById('mines-grid-select').disabled = false;
                document.getElementById('mines-count-input').disabled = false;
                if (!won) {
                    document.getElementById('mines-current-win').innerText = "BUST!";
                    document.getElementById('mines-current-win').className = "text-lg font-bold text-red-500 font-mono";
                    GameConfig.recordHistory(); // FIX: Record loss for graph
                }
            }
            updateStatus() {
                const win = this.bet * this.currentMultiplier;
                document.getElementById('mines-current-win').innerText = win.toFixed(2);
                document.getElementById('mines-current-win').className = "text-lg font-bold text-emerald-400 font-mono";
                if (this.safeRemaining > 0) {
                    const nextProb = this.safeRemaining / this.totalRemaining;
                    const next = (this.currentMultiplier * (1 / nextProb)) * 0.97;
                    document.getElementById('mines-next-mult').innerText = `Next: x${next.toFixed(2)}`;
                } else document.getElementById('mines-next-mult').innerText = "Clear!";
            }
            renderGrid(preview) {
                const con = document.getElementById('mines-board');
                con.innerHTML = '';
                con.style.gridTemplateColumns = `repeat(${this.gridSize}, 1fr)`;
                const tot = this.gridSize * this.gridSize;
                for (let i = 0; i < tot; i++) {
                    const d = document.createElement('div');
                    d.id = `mine-tile-${i}`;
                    d.className = 'mine-tile';
                    if (!preview) d.onclick = () => this.clickTile(i);
                    con.appendChild(d);
                }
            }
        }

        // --- SCRATCH CARDS ---
        class ScratchGame {
            constructor() {
                this.canvas = document.getElementById('scratch-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('scratch-area');
                this.tickets = [
                    { id: 0, name: "Penny Scratcher", price: 1, max: 10, color: "#94a3b8" },
                    { id: 1, name: "Lucky 7s", price: 2, max: 50, color: "#ef4444" },
                    { id: 2, name: "Neon Nights", price: 5, max: 200, color: "#a855f7" },
                    { id: 3, name: "Golden Goose", price: 10, max: 500, color: "#eab308" },
                    { id: 4, name: "Diamond Hands", price: 20, max: 1500, color: "#06b6d4" },
                    { id: 5, name: "Ruby Red", price: 50, max: 5000, color: "#be123c" },
                    { id: 6, name: "Sapphire Sky", price: 100, max: 15000, color: "#1e40af" },
                    { id: 7, name: "Emerald City", price: 250, max: 50000, color: "#047857" },
                    { id: 8, name: "Platinum VIP", price: 500, max: 250000, color: "#334155" },
                    { id: 9, name: "The Jackpot", price: 1000, max: 1000000, color: "#000000" }
                ];
                this.currentTicketId = 4;
                this.isScratching = false;
                this.isRevealed = false;
                this.scratchThreshold = 0.5; // 50% scratched to auto-reveal
                this.ticketActive = false;

                // Bind events
                this.setupEvents();
                this.selectTicket(4); // Default
            }

            selectTicket(id) {
                if (this.ticketActive) {
                    if (!confirm("Abandon current ticket?")) {
                        document.getElementById('scratch-ticket-select').value = this.currentTicketId;
                        return;
                    }
                    this.ticketActive = false;
                }

                this.currentTicketId = parseInt(id);
                const t = this.tickets[this.currentTicketId];

                // Update UI
                document.getElementById('scratch-info-name').innerText = t.name;
                document.getElementById('scratch-info-prize').innerText = "$" + t.max.toLocaleString();
                document.getElementById('scratch-buy-price').innerText = "$" + t.price.toFixed(2);
                document.getElementById('scratch-ticket-select').value = id;

                // Reset Visual
                this.resetPreview();
            }



            resetPreview() {
                const t = this.tickets[this.currentTicketId];

                // Resize Canvas
                this.canvas.width = this.container.clientWidth;
                this.canvas.height = this.container.clientHeight;

                // Draw Preview Foil (Clean)
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.fillStyle = t.color;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Pattern
                this.ctx.fillStyle = "rgba(255,255,255,0.1)";
                for (let i = 0; i < this.canvas.width; i += 20) {
                    this.ctx.fillRect(i, 0, 10, this.canvas.height);
                }

                // Logo/Text
                this.ctx.fillStyle = "#fff";
                this.ctx.font = "bold 24px Inter";
                this.ctx.textAlign = "center";
                this.ctx.shadowColor = "rgba(0,0,0,0.5)";
                this.ctx.shadowBlur = 5;
                this.ctx.fillText(t.name, this.canvas.width / 2, this.canvas.height / 2 - 20);
                this.ctx.font = "16px Inter";
                this.ctx.fillText("Scratch to Reveal", this.canvas.width / 2, this.canvas.height / 2 + 20);
                this.ctx.shadowBlur = 0;

                // Reset Result Layer
                const resLayer = document.getElementById('scratch-result-layer');
                resLayer.style.background = "#fff";
                document.getElementById('scratch-outcome-display').innerText = "???";
                document.getElementById('scratch-outcome-display').className = "text-4xl font-black text-slate-400 my-4 transform rotate-[-5deg]";

                this.ticketActive = false;
                this.isRevealed = false;
                document.getElementById('scratch-btn-buy').disabled = false;
                document.getElementById('scratch-btn-buy').classList.remove('opacity-50', 'cursor-not-allowed');
                document.getElementById('scratch-btn-buy').innerHTML = `<span>BUY TICKET</span><span id="scratch-buy-price" class="bg-black/20 px-2 py-0.5 rounded text-xs">$${t.price.toFixed(2)}</span>`;
            }

            buyTicket() {
                this.resetPreview();
                const t = this.tickets[this.currentTicketId];
                if (!GameConfig.deduct(t.price)) {
                    alert("Not enough funds!");
                    return;
                }

                this.ticketActive = true;
                this.isRevealed = false;

                // Determine Result Immediately
                const r = Math.random();
                let win = 0;
                let text = "TRY AGAIN";
                let style = "text-slate-400";

                // Probabilities
                // 82.45% Loss
                // 10% Money Back or Small Win (1x - 2x)
                // 5% Medium Win (5x)
                // 2.5% Big Win (10x - 20x)
                // 0.05% Jackpot (Max)
                console.log(r);

                if (r > 0.8245) {
                    // Win Logic
                    if (r > 0.9995) { win = t.max; text = "JACKPOT!"; style = "text-purple-600"; }
                    else if (r > 0.975) { win = t.price * (10 + Math.random() * 10); text = "BIG WIN!"; style = "text-emerald-500"; }
                    else if (r > 0.925) { win = t.price * 5; text = "NICE!"; style = "text-blue-500"; }
                    else { win = t.price * (1 + Math.random()); text = "WINNER"; style = "text-green-600"; }

                    // Round
                    win = Math.floor(win);
                }

                // Setup Result Layer
                document.getElementById('scratch-outcome-display').innerText = win > 0 ? `$${win}` : text;
                document.getElementById('scratch-outcome-display').className = `text-5xl font-black ${style} my-4 transform rotate-[-5deg]`;
                document.getElementById('scratch-code').innerText = Math.random().toString(36).substring(7).toUpperCase();

                // Store result for claim
                this.pendingWin = win;

                // UI State
                document.getElementById('scratch-btn-buy').disabled = true;
                document.getElementById('scratch-btn-buy').classList.add('opacity-50', 'cursor-not-allowed');
                document.getElementById('scratch-btn-buy').innerText = "SCRATCH IT!";
            }

            setupEvents() {
                // Mouse/Touch events for scratching
                const start = (e) => {
                    if (!this.ticketActive || this.isRevealed) return;
                    this.isScratching = true;
                    this.scratch(e);
                };
                const end = () => {
                    this.isScratching = false;
                    if (this.ticketActive && !this.isRevealed) this.checkProgress();
                };
                const move = (e) => {
                    if (this.isScratching) {
                        e.preventDefault();
                        this.scratch(e);
                    }
                };

                this.canvas.addEventListener('mousedown', start);
                this.canvas.addEventListener('touchstart', start);

                window.addEventListener('mouseup', end);
                window.addEventListener('touchend', end);

                this.canvas.addEventListener('mousemove', move);
                this.canvas.addEventListener('touchmove', move);
            }

            scratch(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
                const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;

                this.ctx.globalCompositeOperation = 'destination-out';
                this.ctx.beginPath();
                this.ctx.arc(x, y, 25, 0, Math.PI * 2); // 25px brush size
                this.ctx.fill();
            }

            checkProgress() {
                // Expensive operation, only run on mouse up
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const pixels = imageData.data;
                let transparent = 0;

                // Sample every 10th pixel for performance
                for (let i = 0; i < pixels.length; i += 40) {
                    if (pixels[i + 3] < 128) transparent++;
                }

                const total = pixels.length / 40;
                const percent = transparent / total;

                if (percent > this.scratchThreshold) {
                    this.revealAll();
                }
            }

            revealAll() {
                this.isRevealed = true;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Pay out
                if (this.pendingWin > 0) {
                    GameConfig.add(this.pendingWin);
                    // Confetti/Fx could go here
                } else {
                    GameConfig.recordHistory();
                }

                // Reset Button
                document.getElementById('scratch-btn-buy').disabled = false;
                document.getElementById('scratch-btn-buy').classList.remove('opacity-50', 'cursor-not-allowed');
                document.getElementById('scratch-btn-buy').innerHTML = `<span>PLAY AGAIN</span>`;
                this.ticketActive = false;
            }
        }

        // --- ROCKET (Exponential) ---
        class RocketGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.gameState = 'idle'; // idle, running, crashed, cashed
                this.mult = 1.00;
                this.bet = 0;
                this.crashPoint = 0;
                this.startTime = 0;
                this.stars = [];
                this.history = []; // Points for graph

                // Seed System (Linear Congruential Generator for traceability)
                // seed_n+1 = (a * seed_n + c) % m
                this.seed = Math.floor(Math.random() * 4294967296); // Initial random seed
                this.updateSeedDisplay();

                // Config
                this.growthSpeed = 0.0006; // Exponential factor

                this.resize();
                window.addEventListener('resize', () => this.resize());

                // Init Stars
                for (let i = 0; i < 50; i++) {
                    this.stars.push({
                        x: Math.random() * 800,
                        y: Math.random() * 600,
                        size: Math.random() * 2,
                        speed: Math.random() * 2 + 0.5
                    });
                }

                this.animate();
            }

            resize() {
                if (!this.canvas.offsetParent) return;
                this.width = this.canvas.parentElement.clientWidth;
                this.height = this.canvas.parentElement.clientHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
            }

            // Deterministic Seed Generation
            nextSeed() {
                // LCG Parameters (Numerical Recipes)
                const a = 1664525;
                const c = 1013904223;
                const m = 4294967296;
                this.seed = (a * this.seed + c) % m;
                this.updateSeedDisplay();
                return this.seed;
            }

            updateSeedDisplay() {
                const el = document.getElementById('rocket-seed-display');
                if (el) el.innerText = this.seed;
            }

            getCrashPointFromSeed(seed) {
                // Map seed to 0-1 uniform float
                // Ensure we don't divide by zero or hit exact 1
                const random = (seed % 1000000) / 1000000;

                // House Edge: 4% (0.96 RTP)
                // Distribution: 0.96 / (1 - random)
                // This creates the standard crypto-game curve

                const houseEdge = 0.96;
                const crash = houseEdge / (1 - random);

                return Math.max(1.0, crash);
            }

            launch() {
                if (this.gameState === 'running') return;

                const betInput = document.getElementById('bet-input-rocket');
                const bet = parseFloat(betInput.value);
                if (!GameUI.validateBet(bet)) return;

                this.bet = bet;
                this.gameState = 'running';
                this.mult = 1.00;
                this.startTime = Date.now();
                this.history = [{ t: 0, m: 1 }];

                // Generate next traceable seed
                const roundSeed = this.nextSeed();
                this.crashPoint = this.getCrashPointFromSeed(roundSeed);

                // UI Toggle
                document.getElementById('rocket-btn-launch').classList.add('hidden');
                document.getElementById('rocket-btn-eject').classList.remove('hidden');
            }

            eject() {
                if (this.gameState !== 'running') return;
                this.gameState = 'cashed';
                GameConfig.add(this.bet * this.mult);

                document.getElementById('rocket-btn-launch').classList.remove('hidden');
                document.getElementById('rocket-btn-eject').classList.add('hidden');
            }

            update() {
                if (this.gameState === 'running') {
                    // Exponential Growth Logic
                    const elapsed = Date.now() - this.startTime;
                    // Formula: M(t) = e^(k*t)
                    this.mult = Math.exp(this.growthSpeed * elapsed);

                    // Update History for Graph
                    this.history.push({ t: elapsed, m: this.mult });
                    if (this.history.length > 200) this.history.shift(); // Keep last 200 pts

                    // Auto Cashout Check
                    const autoVal = parseFloat(document.getElementById('rocket-auto-cashout').value);
                    if (!isNaN(autoVal) && autoVal > 1.0 && this.mult >= autoVal) {
                        this.eject();
                    }

                    // Crash Check
                    if (this.mult >= this.crashPoint) {
                        this.gameState = 'crashed';
                        document.getElementById('rocket-btn-launch').classList.remove('hidden');
                        document.getElementById('rocket-btn-eject').classList.add('hidden');
                        GameConfig.recordHistory(); // FIX: Record loss for graph
                    }
                }
            }

            drawRocket(x, y) {
                this.ctx.save();
                this.ctx.translate(x, y);

                // Shake effect when running
                if (this.gameState === 'running') {
                    this.ctx.rotate((Math.random() - 0.5) * 0.05);
                }

                // Flame (Animated)
                if (this.gameState === 'running') {
                    this.ctx.fillStyle = '#f59e0b'; // Amber
                    this.ctx.beginPath();
                    this.ctx.moveTo(-10, 25);
                    this.ctx.lineTo(0, 45 + Math.random() * 15);
                    this.ctx.lineTo(10, 25);
                    this.ctx.fill();

                    this.ctx.fillStyle = '#ef4444'; // Red core
                    this.ctx.beginPath();
                    this.ctx.moveTo(-5, 25);
                    this.ctx.lineTo(0, 35 + Math.random() * 10);
                    this.ctx.lineTo(5, 25);
                    this.ctx.fill();
                }

                // Rocket Body
                this.ctx.fillStyle = '#cbd5e1'; // Slate-300
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, 15, 35, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Shading (Right side darker)
                this.ctx.fillStyle = 'rgba(0,0,0,0.1)';
                this.ctx.beginPath();
                this.ctx.ellipse(3, 0, 10, 33, 0, -Math.PI / 2, Math.PI / 2);
                this.ctx.fill();

                // Fins
                this.ctx.fillStyle = '#ef4444'; // Red
                // Left Fin
                this.ctx.beginPath();
                this.ctx.moveTo(-12, 15);
                this.ctx.lineTo(-28, 35);
                this.ctx.lineTo(-10, 28);
                this.ctx.fill();
                // Right Fin
                this.ctx.beginPath();
                this.ctx.moveTo(12, 15);
                this.ctx.lineTo(28, 35);
                this.ctx.lineTo(10, 28);
                this.ctx.fill();
                // Center Fin
                this.ctx.beginPath();
                this.ctx.rect(-2, 15, 4, 20);
                this.ctx.fill();

                // Window (Porthole)
                this.ctx.fillStyle = '#3b82f6'; // Blue glass
                this.ctx.beginPath();
                this.ctx.arc(0, -10, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // Window Frame
                this.ctx.strokeStyle = '#94a3b8';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                // Reflection on glass
                this.ctx.fillStyle = 'rgba(255,255,255,0.6)';
                this.ctx.beginPath();
                this.ctx.arc(-3, -13, 3, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.restore();
            }

            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);

                // Draw Stars (Parallax)
                this.ctx.fillStyle = '#fff';
                this.stars.forEach(s => {
                    this.ctx.beginPath();
                    this.ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    // Move stars down to simulate upward movement
                    if (this.gameState === 'running') s.y += s.speed * (1 + (this.mult * 0.1));
                    if (s.y > this.height) s.y = 0;
                });

                // Center Text
                this.ctx.textAlign = 'center';
                this.ctx.font = 'bold 40px Inter';

                if (this.gameState === 'running') {
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillText(`${this.mult.toFixed(2)}x`, this.width / 2, this.height / 2 - 60);

                    // Draw Rocket
                    this.drawRocket(this.width / 2, this.height / 2);

                } else if (this.gameState === 'crashed') {
                    this.ctx.fillStyle = '#ef4444';
                    this.ctx.fillText(`CRASHED @ ${this.crashPoint.toFixed(2)}x`, this.width / 2, this.height / 2 - 60);

                    // Explosion visual
                    this.ctx.font = '60px Inter';
                    this.ctx.fillText("üí•", this.width / 2, this.height / 2);

                } else if (this.gameState === 'cashed') {
                    this.ctx.fillStyle = '#34d399';
                    this.ctx.fillText(`CASHED: ${this.mult.toFixed(2)}x`, this.width / 2, this.height / 2 - 60);

                    // Show what it CRASHED at
                    this.ctx.fillStyle = '#64748b'; // Slate for the "missed out" info
                    this.ctx.font = 'bold 20px Inter';
                    this.ctx.fillText(`Crashed @ ${this.crashPoint.toFixed(2)}x`, this.width / 2, this.height / 2 - 20);

                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '20px Inter';
                    this.ctx.fillText(`Win: ${(this.bet * this.mult).toFixed(2)}`, this.width / 2, this.height / 2 + 10);

                    // Rocket flying away (up)
                    this.drawRocket(this.width / 2, this.height / 2 - 120);

                } else {
                    // Idle
                    this.ctx.fillStyle = '#94a3b8';
                    this.ctx.fillText("Ready for Launch", this.width / 2, this.height / 2 - 60);
                    this.drawRocket(this.width / 2, this.height / 2);
                }

                // Draw Graph Curve (Visualizing Exponential Growth)
                if (this.history.length > 1) {
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = this.gameState === 'crashed' ? '#ef4444' : '#3b82f6';
                    this.ctx.lineWidth = 3;

                    const maxM = Math.max(2, this.history[this.history.length - 1].m);

                    this.history.forEach((pt, i) => {
                        const x = (i / this.history.length) * this.width;
                        const y = this.height - ((pt.m / (maxM * 1.1)) * (this.height * 0.5)); // Use bottom 50% of screen
                        if (i === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    });
                    this.ctx.stroke();
                }
            }

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        // --- CASES (Loot Box) ---
        class CasesGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.isSpinning = false;
                this.view = 'menu'; // 'menu' or 'spinning'
                this.selectedCase = null;

                // DATA: 10 Unique Cases
                this.casesData = [
                    {
                        id: 'budget', name: 'Budget', price: 10, color: '#94a3b8', items: [
                            { name: 'Paperclip', val: 1, chance: 0.5449, color: '#64748b', icon: 'üìé' },
                            { name: 'Soda', val: 8, chance: 0.35, color: '#3b82f6', icon: 'ü•§' },
                            { name: 'Burger', val: 30, chance: 0.10, color: '#a855f7', icon: 'üçî' },
                            { name: 'Watch', val: 500, chance: 0.005, color: '#eab308', icon: '‚åö' },
                            { name: 'JACKPOT', val: 10000, chance: 0.0001, color: '#ff00ff', icon: 'üé∞' }
                        ]
                    },
                    {
                        id: 'starter', name: 'Starter', price: 50, color: '#3b82f6', items: [
                            { name: 'Sock', val: 5, chance: 0.5449, color: '#64748b', icon: 'üß¶' },
                            { name: 'Hat', val: 40, chance: 0.35, color: '#3b82f6', icon: 'üß¢' },
                            { name: 'Headphones', val: 150, chance: 0.10, color: '#a855f7', icon: 'üéß' },
                            { name: 'Phone', val: 2500, chance: 0.005, color: '#eab308', icon: 'üì±' },
                            { name: 'JACKPOT', val: 50000, chance: 0.0001, color: '#ff00ff', icon: 'üé∞' }
                        ]
                    },
                    {
                        id: 'street', name: 'Street', price: 100, color: '#10b981', items: [
                            { name: 'Brick', val: 10, chance: 0.5449, color: '#64748b', icon: 'üß±' },
                            { name: 'Sneakers', val: 80, chance: 0.35, color: '#3b82f6', icon: 'üëü' },
                            { name: 'Spray Paint', val: 300, chance: 0.10, color: '#a855f7', icon: 'üé®' },
                            { name: 'Bike', val: 5000, chance: 0.005, color: '#eab308', icon: 'üö≤' },
                            { name: 'JACKPOT', val: 100000, chance: 0.0001, color: '#ff00ff', icon: 'üé∞' }
                        ]
                    },
                    {
                        id: 'gamer', name: 'Gamer', price: 500, color: '#8b5cf6', items: [
                            { name: 'Cable', val: 50, chance: 0.5449, color: '#64748b', icon: 'üîå' },
                            { name: 'Keyboard', val: 400, chance: 0.35, color: '#3b82f6', icon: '‚å®Ô∏è' },
                            { name: 'Console', val: 1500, chance: 0.10, color: '#a855f7', icon: 'üéÆ' },
                            { name: 'PC', val: 25000, chance: 0.005, color: '#eab308', icon: 'üñ•Ô∏è' },
                            { name: 'JACKPOT', val: 500000, chance: 0.0001, color: '#ff00ff', icon: 'üé∞' }
                        ]
                    },
                    {
                        id: 'luxury', name: 'Luxury', price: 2500, color: '#f59e0b', items: [
                            { name: 'Rock', val: 250, chance: 0.5449, color: '#64748b', icon: 'ü™®' },
                            { name: 'Ring', val: 2000, chance: 0.35, color: '#3b82f6', icon: 'üíç' },
                            { name: 'Suit', val: 7500, chance: 0.10, color: '#a855f7', icon: 'üëî' },
                            { name: 'Diamond', val: 125000, chance: 0.005, color: '#eab308', icon: 'üíé' },
                            { name: 'JACKPOT', val: 2500000, chance: 0.0001, color: '#ff00ff', icon: 'üé∞' }
                        ]
                    },
                    {
                        id: 'vehicle', name: 'Garage', price: 10000, color: '#ef4444', items: [
                            { name: 'Tire', val: 1000, chance: 0.5449, color: '#64748b', icon: 'üç©' },
                            { name: 'Scooter', val: 8000, chance: 0.35, color: '#3b82f6', icon: 'üõ¥' },
                            { name: 'Sedan', val: 30000, chance: 0.10, color: '#a855f7', icon: 'üöó' },
                            { name: 'Supercar', val: 500000, chance: 0.005, color: '#eab308', icon: 'üèéÔ∏è' },
                            { name: 'JACKPOT', val: 10000000, chance: 0.0001, color: '#ff00ff', icon: 'üé∞' }
                        ]
                    },
                    {
                        id: 'estate', name: 'Estate', price: 50000, color: '#06b6d4', items: [
                            { name: 'Tent', val: 5000, chance: 0.5449, color: '#64748b', icon: '‚õ∫' },
                            { name: 'Shed', val: 40000, chance: 0.35, color: '#3b82f6', icon: 'üèöÔ∏è' },
                            { name: 'House', val: 150000, chance: 0.10, color: '#a855f7', icon: 'üè†' },
                            { name: 'Mansion', val: 2500000, chance: 0.005, color: '#eab308', icon: 'üè∞' },
                            { name: 'JACKPOT', val: 50000000, chance: 0.0001, color: '#ff00ff', icon: 'üé∞' }
                        ]
                    },
                    {
                        id: 'crypto', name: 'Crypto', price: 100000, color: '#f97316', items: [
                            { name: 'Rugpull', val: 10000, chance: 0.5449, color: '#64748b', icon: 'üìâ' },
                            { name: 'Altcoin', val: 80000, chance: 0.35, color: '#3b82f6', icon: 'ü™ô' },
                            { name: 'Ethereum', val: 300000, chance: 0.10, color: '#a855f7', icon: '‚ö™' },
                            { name: 'Bitcoin', val: 5000000, chance: 0.005, color: '#eab308', icon: '‚Çø' },
                            { name: 'JACKPOT', val: 100000000, chance: 0.0001, color: '#ff00ff', icon: 'üé∞' }
                        ]
                    },
                    {
                        id: 'space', name: 'Cosmic', price: 500000, color: '#d946ef', items: [
                            { name: 'Dust', val: 50000, chance: 0.5449, color: '#64748b', icon: 'üå´Ô∏è' },
                            { name: 'Satellite', val: 400000, chance: 0.35, color: '#3b82f6', icon: 'üõ∞Ô∏è' },
                            { name: 'Rocket', val: 1500000, chance: 0.10, color: '#a855f7', icon: 'üöÄ' },
                            { name: 'Planet', val: 25000000, chance: 0.005, color: '#eab308', icon: 'ü™ê' },
                            { name: 'JACKPOT', val: 500000000, chance: 0.0001, color: '#ff00ff', icon: 'üé∞' }
                        ]
                    },
                    {
                        id: 'godly', name: 'Godly', price: 1000000, color: '#eab308', items: [
                            { name: 'Mortal', val: 100000, chance: 0.5449, color: '#64748b', icon: 'üßç' },
                            { name: 'Angel', val: 800000, chance: 0.35, color: '#3b82f6', icon: 'üëº' },
                            { name: 'Zeus', val: 3000000, chance: 0.10, color: '#a855f7', icon: '‚ö°' },
                            { name: 'Omnipotence', val: 50000000, chance: 0.005, color: '#eab308', icon: 'üî±' },
                            { name: 'JACKPOT', val: 1000000000, chance: 0.0001, color: '#ff00ff', icon: 'üé∞' }
                        ]
                    }
                ];

                this.tape = [];
                this.cardWidth = 140;
                this.cardGap = 10;
                this.offsetX = 0;
                this.targetX = 0;

                this.resize();
                window.addEventListener('resize', () => this.resize());

                // Add Click Listener for Menu
                this.canvas.addEventListener('click', (e) => this.handleClick(e));

                this.animate();
            }
            resize() {
                if (!this.canvas.offsetParent) return;
                this.width = this.canvas.parentElement.clientWidth;
                this.height = this.canvas.parentElement.clientHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
            }

            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (this.view === 'spinning' && !this.isSpinning) {
                    if (x < 100 && y < 50) {
                        this.backToMenu();
                        return;
                    }
                }

                if (this.view !== 'menu') return;

                // Responsive Grid Logic
                const cardW = 160;
                const cardH = 100;
                const gapX = 20;
                const gapY = 20;

                // Calculate Columns based on width
                const availableW = this.width - 40; // 20px padding
                let cols = Math.floor(availableW / (cardW + gapX));
                cols = Math.max(1, cols);

                const gridW = cols * (cardW + gapX) - gapX;
                const startX = (this.width - gridW) / 2;
                const startY = 80;

                for (let i = 0; i < this.casesData.length; i++) {
                    const row = Math.floor(i / cols);
                    const col = i % cols;
                    const cx = startX + col * (cardW + gapX);
                    const cy = startY + row * (cardH + gapY);

                    if (x >= cx && x <= cx + cardW && y >= cy && y <= cy + cardH) {
                        this.openCaseMenu(this.casesData[i]);
                        break;
                    }
                }
            }

            openCaseMenu(caseObj) {
                this.selectedCase = caseObj;
                this.view = 'spinning';

                document.getElementById('cases-price-display').innerText = `Price: $${caseObj.price.toLocaleString()}`;

                const btn = document.getElementById('play-btn-cases');
                const canAfford = GameConfig.credits >= caseObj.price;

                btn.innerText = `OPEN ${caseObj.name.toUpperCase()} ($${caseObj.price})`;

                if (canAfford) {
                    btn.className = "w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 rounded-lg shadow-lg active:scale-95 transition-transform";
                } else {
                    btn.className = "w-full bg-slate-700 text-slate-400 font-bold py-4 rounded-lg shadow-lg cursor-not-allowed";
                }

                btn.onclick = () => {
                    if (GameConfig.credits >= caseObj.price) {
                        this.spin();
                    } else {
                        alert("Not enough credits!");
                    }
                };
            }

            backToMenu() {
                this.view = 'menu';
                this.selectedCase = null;
                const btn = document.getElementById('play-btn-cases');
                btn.innerText = "SELECT A CASE";
                btn.className = "w-full bg-slate-700 text-slate-400 font-bold py-4 rounded-lg shadow-lg cursor-default transition-all duration-200";
                btn.onclick = null;
                document.getElementById('cases-price-display').innerText = "Select Case";
                this.draw();
            }

            getRandomItem(items) {
                const r = Math.random();
                let sum = 0;
                for (let item of items) {
                    sum += item.chance;
                    if (r < sum) return item;
                }
                return items[items.length - 1];
            }

            spin() {
                if (this.isSpinning || !this.selectedCase) return;
                if (!GameConfig.deduct(this.selectedCase.price)) {
                    alert("Not enough credits!");
                    return;
                }

                this.isSpinning = true;
                document.getElementById('cases-result').innerText = "Spinning...";
                document.getElementById('cases-result').className = "text-sm font-bold h-6 text-slate-300";

                // Generate Tape
                this.tape = [];
                for (let i = 0; i < 50; i++) {
                    this.tape.push(this.getRandomItem(this.selectedCase.items));
                }

                // Determine Winner (Last item logic or fixed position)
                // Let's make index 40 the winner
                const winner = this.getRandomItem(this.selectedCase.items);
                this.tape[40] = winner; // Force winner at pos 40

                // Animation Params
                // Align index 40 to center of screen
                // x = (index * (cardW + gap))
                const cardTotalW = this.cardWidth + this.cardGap;
                const winnerX = 40 * cardTotalW;
                // We want winnerX to be at center: width/2 - cardWidth/2
                // targetOffset = winnerX - (width/2 - cardWidth/2)
                const endPos = winnerX - (this.width / 2) + (this.cardWidth / 2);

                // Add jitter
                const jitter = (Math.random() - 0.5) * (this.cardWidth * 0.7);
                this.targetX = endPos + jitter;

                // Reset Offset
                this.offsetX = 0;

                // ANIMATION
                const duration = 6000;
                const start = Date.now();
                const startX = 0;
                const distance = this.targetX;

                const animateScroll = () => {
                    const now = Date.now();
                    const elapsed = now - start;
                    const progress = Math.min(elapsed / duration, 1);
                    // Cubic Ease Out
                    const ease = 1 - Math.pow(1 - progress, 3);

                    this.offsetX = startX + (distance * ease);

                    if (progress < 1) {
                        requestAnimationFrame(animateScroll);
                    } else {
                        this.finish(winner);
                    }
                };
                animateScroll();
            }

            finish(item) {
                this.isSpinning = false;
                if (item.val > 0) {
                    GameConfig.add(item.val);
                    document.getElementById('cases-result').innerText = `${item.name}! +$${item.val.toLocaleString()}`;
                    document.getElementById('cases-result').className = "text-sm font-bold h-6 text-emerald-400 neon-text";
                } else {
                    GameConfig.recordHistory();
                    document.getElementById('cases-result').innerText = `${item.name} (Trash)`;
                    document.getElementById('cases-result').className = "text-sm font-bold h-6 text-slate-500";
                }
            }

            update() { }

            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);

                const cardTotalW = this.cardWidth + this.cardGap;
                const centerScreen = this.width / 2;

                // Draw Items
                this.items.forEach((item, i) => {
                    const x = (i * cardTotalW) - this.offsetX;
                    // Optimization: visible only
                    if (x < -this.cardWidth || x > this.width) return;

                    const y = (this.height - 140) / 2;
                    const h = 140;

                    // Card Bg
                    this.ctx.fillStyle = '#1e293b';
                    this.ctx.fillRect(x, y, this.cardWidth, h);

                    // Color Bar Bottom
                    this.ctx.fillStyle = item.color;
                    this.ctx.fillRect(x, y + h - 10, this.cardWidth, 10);

                    // Border (only if high rarity?)
                    this.ctx.strokeStyle = item.color;
                    this.ctx.lineWidth = item.mult > 2 ? 3 : 1;
                    this.ctx.strokeRect(x, y, this.cardWidth, h);

                    // Image Placeholder (Circle)
                    this.ctx.beginPath();
                    this.ctx.arc(x + this.cardWidth / 2, y + 60, 30, 0, Math.PI * 2);
                    this.ctx.fillStyle = '#0f172a';
                    this.ctx.fill();

                    // Text
                    this.ctx.fillStyle = item.color; // Color text too
                    this.ctx.font = 'bold 24px Inter';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(`${item.mult}x`, x + this.cardWidth / 2, y + 70);

                    this.ctx.font = '10px Inter';
                    this.ctx.fillStyle = '#64748b';
                    this.ctx.fillText(item.name.toUpperCase(), x + this.cardWidth / 2, y + 120);
                });

                // Center Line (The Marker)
                this.ctx.beginPath();
                this.ctx.strokeStyle = '#eab308'; // Gold marker
                this.ctx.lineWidth = 3;
                this.ctx.moveTo(centerScreen, 20);
                this.ctx.lineTo(centerScreen, this.height - 20);
                this.ctx.shadowColor = '#eab308';
                this.ctx.shadowBlur = 10;
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;

                // Triangle Marker Top
                this.ctx.fillStyle = '#eab308';
                this.ctx.beginPath();
                this.ctx.moveTo(centerScreen - 10, 20);
                this.ctx.lineTo(centerScreen + 10, 20);
                this.ctx.lineTo(centerScreen, 40);
                this.ctx.fill();

                // Bottom Marker
                this.ctx.beginPath();
                this.ctx.moveTo(centerScreen - 10, this.height - 20);
                this.ctx.lineTo(centerScreen + 10, this.height - 20);
                this.ctx.lineTo(centerScreen, this.height - 40);
                this.ctx.fill();
            }

            animate() {
                this.draw();
                if (this.view === 'spinning' || this.isSpinning) {
                    requestAnimationFrame(() => this.animate());
                } else {
                    setTimeout(() => requestAnimationFrame(() => this.animate()), 50);
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);

                if (this.view === 'menu') {
                    this.drawMenu();
                } else {
                    this.drawSpinner();
                }
            }

            drawMenu() {
                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 24px Inter';
                this.ctx.textAlign = 'center';
                this.ctx.fillText("SELECT A CASE", this.width / 2, 40);

                // Responsive Grid Logic
                const cardW = 160;
                const cardH = 100;
                const gapX = 20;
                const gapY = 20;

                // Keep visually centered
                // We use Math.floor to ensure we don't overestimate columns
                const availableW = this.width - 40;
                let cols = Math.floor(availableW / (cardW + gapX));
                cols = Math.max(1, cols);

                // Recalculate grid width based on actual cols to perfectly center
                const gridW = cols * cardW + (cols - 1) * gapX;
                const startX = (this.width - gridW) / 2;
                const startY = 80;

                this.casesData.forEach((c, i) => {
                    const row = Math.floor(i / cols);
                    const col = i % cols;
                    const x = startX + col * (cardW + gapX);
                    const y = startY + row * (cardH + gapY);

                    // Box
                    this.ctx.fillStyle = '#1e293b';
                    this.ctx.fillRect(x, y, cardW, cardH);

                    // Gradient or Border
                    this.ctx.strokeStyle = c.color;
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(x, y, cardW, cardH);

                    // Name
                    this.ctx.fillStyle = c.color;
                    this.ctx.font = 'bold 16px Inter';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(c.name, x + cardW / 2, y + 30);

                    // Icon (Preview)
                    this.ctx.font = '24px Inter';
                    this.ctx.fillText(c.items[3].icon, x + cardW / 2, y + 60);

                    // Price
                    this.ctx.fillStyle = '#94a3b8';
                    this.ctx.font = '12px Inter';
                    this.ctx.fillText(`$${c.price.toLocaleString()}`, x + cardW / 2, y + 85);
                });
            }

            drawSpinner() {
                // Back Button
                if (!this.isSpinning) {
                    this.ctx.fillStyle = '#64748b';
                    this.ctx.font = '14px Inter';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText("‚¨Ö BACK", 20, 30);
                }

                const cardTotalW = this.cardWidth + this.cardGap;
                const titleY = 40;

                // Case Title
                this.ctx.fillStyle = this.selectedCase.color;
                this.ctx.font = 'bold 24px Inter';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(this.selectedCase.name.toUpperCase(), this.width / 2, titleY);

                // Draw Tape
                const centerY = this.height / 2;

                // Center Line (The Marker)
                if (this.tape.length > 0) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.width / 2, centerY - 80);
                    this.ctx.lineTo(this.width / 2, centerY + 80);
                    this.ctx.strokeStyle = '#eab308';
                    this.ctx.lineWidth = 4;
                    this.ctx.stroke();
                }

                // Draw Items
                if (this.tape.length === 0) {
                    // SHOW PRIZE PREVIEW (All items in a row)
                    const totalPreviewW = (5 * (100 + 10)) - 10;
                    const startPreviewX = (this.width - totalPreviewW) / 2;

                    this.ctx.textAlign = 'center';
                    this.ctx.font = '16px Inter';
                    this.ctx.fillStyle = '#94a3b8';
                    this.ctx.fillText("CASE CONTENTS", this.width / 2, centerY - 80);

                    this.selectedCase.items.forEach((item, i) => {
                        const px = startPreviewX + i * 110;
                        const py = centerY - 50;
                        const pw = 100;
                        const ph = 100;

                        // Card
                        this.ctx.fillStyle = '#1e293b';
                        this.ctx.fillRect(px, py, pw, ph);
                        this.ctx.strokeStyle = item.color;
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(px, py, pw, ph);

                        // Icon
                        this.ctx.font = '32px Inter';
                        this.ctx.fillText(item.icon, px + pw / 2, py + 40);

                        // Name
                        this.ctx.fillStyle = item.color;
                        this.ctx.font = '10px Inter';
                        this.ctx.fillText(item.name, px + pw / 2, py + 65);

                        // Value (Restored)
                        this.ctx.fillStyle = '#94a3b8';
                        this.ctx.font = '10px Inter';
                        this.ctx.fillText(`$${item.val.toLocaleString()}`, px + pw / 2, py + 85);
                    });

                    return;
                }

                this.tape.forEach((item, i) => {
                    const x = (i * cardTotalW) - this.offsetX;
                    // Visible check
                    if (x < -this.cardWidth || x > this.width) return;

                    const y = centerY - 70;
                    const h = 140;

                    // Card Bg
                    this.ctx.fillStyle = '#1e293b';
                    this.ctx.fillRect(x, y, this.cardWidth, h);

                    // Color Bar Bottom
                    this.ctx.fillStyle = item.color;
                    this.ctx.fillRect(x, y + h - 10, this.cardWidth, 10);

                    // Border (only if high rarity?)
                    this.ctx.strokeStyle = item.color;
                    this.ctx.lineWidth = item.mult > 2 ? 3 : 1;
                    this.ctx.strokeRect(x, y, this.cardWidth, h);

                    // Image Placeholder (Circle)
                    this.ctx.beginPath();
                    this.ctx.arc(x + this.cardWidth / 2, y + 60, 30, 0, Math.PI * 2);
                    this.ctx.fillStyle = '#0f172a';
                    this.ctx.fill();

                    // Icon inside Value
                    this.ctx.font = '32px Inter';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(item.icon, x + this.cardWidth / 2, y + 70);

                    // Name
                    this.ctx.font = '10px Inter';
                    this.ctx.fillStyle = '#64748b';
                    this.ctx.fillText(item.name.toUpperCase(), x + this.cardWidth / 2, y + 120);

                    // Display Value on Card
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '11px Inter';
                    this.ctx.fillText(`$${item.val.toLocaleString()}`, x + this.cardWidth / 2, y + 135);
                });

                // Redraw Marker on Top
                this.ctx.beginPath();
                this.ctx.moveTo(this.width / 2, centerY - 80);
                this.ctx.lineTo(this.width / 2, centerY + 80);
                this.ctx.strokeStyle = '#eab308';
                this.ctx.lineWidth = 4;
                this.ctx.stroke();

                // Triangle Marker
                this.ctx.fillStyle = '#eab308';
                this.ctx.beginPath();
                this.ctx.moveTo(this.width / 2 - 10, centerY - 85);
                this.ctx.lineTo(this.width / 2 + 10, centerY - 85);
                this.ctx.lineTo(this.width / 2, centerY - 70);
                this.ctx.fill();
            }
        }

        // --- POKER (Texas Hold'em vs Bots) ---
        // --- POKER (Texas Hold'em vs Bots) ---
        class PokerGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.deck = [];
                this.communityCards = [];
                this.pot = 0;
                this.currentBet = 0;

                // Table Config
                this.tables = [
                    { name: 'Micro', bb: 10, sb: 5 },
                    { name: 'Low', bb: 50, sb: 25 },
                    { name: 'Mid', bb: 100, sb: 50 },
                    { name: 'High', bb: 500, sb: 250 },
                    { name: 'High Roller', bb: 1000, sb: 500 }
                ];
                this.selectedTable = null;
                this.inHand = false;
                this.raisesCount = 0; // Track raises per betting round

                this.dealerIdx = 0;
                this.turnIdx = 0;
                this.gamePhase = 'idle';

                // Players using credits directly for Human (id:0)
                this.players = [
                    { id: 0, name: 'You', chips: 0, hand: [], active: true, fold: false, bet: 0, isBot: false },
                    { id: 1, name: 'Bot 1', chips: 100000000, hand: [], active: true, fold: false, bet: 0, isBot: true },
                    { id: 2, name: 'Bot 2', chips: 100000000, hand: [], active: true, fold: false, bet: 0, isBot: true },
                    { id: 3, name: 'Bot 3', chips: 100000000, hand: [], active: true, fold: false, bet: 0, isBot: true },
                    { id: 4, name: 'Bot 4', chips: 100000000, hand: [], active: true, fold: false, bet: 0, isBot: true }
                ];

                this.suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
                this.ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
                this.turnTimer = 0;
                this.actedThisRound = []; // Track who has acted this betting round
                this.lastActions = ['', '', '', '', '']; // Action text per player for display

                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.animate();
            }

            resize() {
                if (!this.canvas.offsetParent) return;
                this.width = this.canvas.parentElement.clientWidth;
                this.height = this.canvas.parentElement.clientHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
            }

            joinTable(tableIndex) {
                this.selectedTable = this.tables[tableIndex];

                // Switch UI
                document.getElementById('poker-lobby').classList.add('hidden');
                document.getElementById('poker-gameplay').classList.remove('hidden');
                document.getElementById('poker-table-info').innerText = `Table: $${this.selectedTable.bb} BB`;

                // Reset State
                this.dealerIdx = Math.floor(Math.random() * 5);

                // Start Hand immediately
                this.updateUI("Starting Hand...");
                setTimeout(() => this.nextHand(), 1000);
            }

            leaveTable() {
                this.selectedTable = null;
                this.inHand = false;
                this.gamePhase = 'idle';
                this.pot = 0;
                this.communityCards = [];
                this.players.forEach(p => { p.hand = []; p.fold = false; p.bet = 0; });

                // Switch UI
                document.getElementById('poker-lobby').classList.remove('hidden');
                document.getElementById('poker-gameplay').classList.add('hidden');
            }

            // Sync Human Chips with Credits
            updateHumanChips() {
                this.players[0].chips = GameConfig.credits;
            }

            createDeck() {
                this.deck = [];
                for (let s of this.suits) {
                    for (let r of this.ranks) {
                        this.deck.push({ suit: s, rank: r, value: this.ranks.indexOf(r) + 2 });
                    }
                }
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            nextHand() {
                if (!this.selectedTable) return;

                // Hide Start Button
                document.getElementById('poker-btn-deal').classList.add('hidden');

                // Check if user has enough credits for Big Blind
                this.updateHumanChips();
                if (this.players[0].chips < this.selectedTable.bb) {
                    alert("Not enough credits for Big Blind!");
                    this.leaveTable();
                    return;
                }

                this.inHand = true;
                this.createDeck();
                this.communityCards = [];
                this.pot = 0;
                this.gamePhase = 'preflop';
                this.raisesCount = 0;
                this.actedThisRound = [];
                this.lastActions = ['', '', '', '', '']; // Clear action indicators

                // Reset Players
                this.players.forEach((p, i) => {
                    p.hand = [this.deck.pop(), this.deck.pop()];
                    p.active = (p.chips > 0);
                    p.fold = !p.active;
                    p.bet = 0;

                    // Reset Bot Stacks if low
                    if (p.isBot && p.chips < this.selectedTable.bb * 20) {
                        p.chips = 100000000;
                    }
                });

                // Blinds Logic
                this.dealerIdx = (this.dealerIdx + 1) % 5;
                const sbIdx = (this.dealerIdx + 1) % 5;
                const bbIdx = (this.dealerIdx + 2) % 5;

                // Post SB
                this.postBlind(this.players[sbIdx], this.selectedTable.sb);
                // Post BB
                this.postBlind(this.players[bbIdx], this.selectedTable.bb);

                this.currentBet = this.selectedTable.bb; // The BB is the "current bet" to match

                // Action starts left of BB Preflop (UTG)
                this.turnIdx = (bbIdx + 1) % 5;

                this.startTurn();
            }

            postBlind(player, amount) {
                let actual = amount;
                if (player.chips < amount) actual = player.chips;
                this.placeBetLogic(player, actual, true);
            }

            startTurn() {
                if (this.gamePhase === 'showdown' || this.gamePhase === 'round_over' || !this.selectedTable) return;

                // Check for Game End FIRST
                const activePlayers = this.players.filter(p => !p.fold);
                if (activePlayers.length === 1) {
                    this.resolveWinner(activePlayers[0]);
                    return;
                }

                // Check if all active players have matched the bet (round complete)
                const playersWhoCanAct = this.players.filter(p => !p.fold && p.chips > 0);
                const allMatched = playersWhoCanAct.every(p => p.bet === this.currentBet);
                const allActed = playersWhoCanAct.every(p => this.actedThisRound.includes(p.id));

                // Big Blind Option in Preflop
                const bbIdx = (this.dealerIdx + 2) % 5;
                const isBBOption = (this.gamePhase === 'preflop' &&
                    this.turnIdx === bbIdx &&
                    this.currentBet === this.selectedTable.bb &&
                    allMatched &&
                    !this.actedThisRound.includes(this.players[bbIdx].id));

                if (allMatched && allActed && !isBBOption) {
                    setTimeout(() => this.advancePhase(), 500);
                    return;
                }

                const currentPlayer = this.players[this.turnIdx];

                // Skip folded or all-in players
                if (currentPlayer.fold || currentPlayer.chips === 0) {
                    this.turnIdx = (this.turnIdx + 1) % 5;
                    setTimeout(() => this.startTurn(), 50);
                    return;
                }

                // It's this player's turn to act
                if (currentPlayer.isBot) {
                    this.updateUI(`${currentPlayer.name} Thinking...`);
                    setTimeout(() => this.botMove(currentPlayer), 1500 + Math.random() * 1000);
                } else {
                    // HUMAN TURN - STOP AND WAIT
                    this.updateUI('Your Turn');
                    this.renderButtons();
                }
            }

            renderButtons() {
                const myTurn = (this.turnIdx === 0 && this.gamePhase !== 'showdown');
                document.getElementById('poker-btn-fold').disabled = !myTurn;
                document.getElementById('poker-btn-check').disabled = !myTurn;
                document.getElementById('poker-btn-raise').disabled = !myTurn;

                const btn = document.getElementById('poker-btn-check');
                const cost = this.currentBet - this.players[0].bet;
                btn.innerText = cost > 0 ? `Call ($${cost})` : 'Check';
            }

            botMove(bot) {
                let strength = this.evaluateHandStrength(bot.hand, this.communityCards);
                const toCall = this.currentBet - bot.bet;
                const potOdds = toCall / (this.pot + toCall);

                let action = 'fold';
                const r = Math.random();

                // Small Blind Defense: If in SB position (Dealer+1), call wider
                const isSB = ((this.dealerIdx + 1) % 5 === bot.id);
                const sbDefense = isSB && toCall <= this.selectedTable.bb && r < 0.7;

                // Raise Cap: After 3 raises, no more raising allowed
                const canRaise = this.raisesCount < 3;

                // Effective Stack Calculation
                const humanStack = this.players[0].chips + this.players[0].bet;
                const effectiveStack = Math.min(bot.chips + bot.bet, humanStack);
                const isPreflop = this.gamePhase === 'preflop';

                // Preflop Logic Enhancement
                if (isPreflop) {
                    const c1 = bot.hand[0], c2 = bot.hand[1];
                    const isPair = c1.value === c2.value;
                    const isSuited = c1.suit === c2.suit;
                    const highCard = Math.max(this.ranks.indexOf(c1.value), this.ranks.indexOf(c2.value));
                    const lowCard = Math.min(this.ranks.indexOf(c1.value), this.ranks.indexOf(c2.value));
                    const gap = highCard - lowCard;

                    // Elite: AA, KK, QQ, AKs, AKo
                    const isElite = (isPair && highCard >= 10) || (highCard === 12 && lowCard === 11);
                    // Good: JJ-88, AQ-AT, KQs
                    const isStrong = (isPair && highCard >= 6) || (highCard >= 10 && lowCard >= 8);
                    // Decent: High Cards (Any Face Card), Suited Connectors, Mid Pairs
                    const isDecent = highCard >= 9 || (isSuited && gap < 3) || isPair;

                    if (isElite) strength = 0.95;
                    else if (isStrong) strength = 0.7;
                    else if (isDecent) strength = 0.45; // Boosted functionality
                    else strength = 0.2;
                }

                // Infinite Loop Prevention: Cap raises in a single round
                if (this.currentBet > this.selectedTable.bb * 20 && strength < 0.9) {
                    if (toCall <= bot.chips) action = 'call';
                    else action = 'fold';
                }
                // Monster Hand (0.8+) - Value Bet heavily
                else if (strength > 0.8) {
                    if (toCall === 0) action = (r < 0.2) ? 'check' : 'raise'; // 80% bet
                    else action = (r < 0.1) ? 'call' : 'raise'; // 90% raise
                }
                // Strong Hand (0.6+) - Protect
                else if (strength > 0.6) {
                    if (toCall === 0) action = (r < 0.3 || !canRaise) ? 'check' : 'raise'; // 70% bet
                    else action = (r < 0.4 && canRaise) ? 'raise' : 'call'; // 60% call, 40% re-raise
                }
                // Marginal/Draw (0.35+) - Call or Semi-Bluff
                else if (strength > 0.35 || sbDefense) {
                    if (toCall === 0) action = (r < 0.6 && canRaise) ? 'raise' : 'check'; // 40% semi-bluff bet

                    // STICKY LOGIC: Call more often with decent cards
                    const isCheap = toCall < this.pot * 0.4;
                    if (strength > potOdds || sbDefense || isCheap) action = 'call';
                    else action = (r < 0.15 && canRaise) ? 'bluff' : 'fold';
                }
                // Weak Hand - fold mostly, rare bluff
                else {
                    if (toCall === 0) action = (r < 0.2 && canRaise) ? 'raise' : 'check'; // 20% bluff
                    // FLOAT LOGIC: Call cheap bets with "meh" cards if in position or just curious
                    else if (toCall < this.selectedTable.bb * 3 && r < 0.4) action = 'call';
                    else action = 'fold';
                }

                if (toCall >= bot.chips * 0.6 && strength < 0.6) action = 'fold';
                if (action === 'bluff') action = 'raise';
                if (toCall > bot.chips) action = 'allin';

                if (action === 'raise') {
                    // Bot raise multiplier
                    let raiseAmt = this.currentBet * 2 || this.selectedTable.bb * 2;

                    // CAP RAISE to Effective Stack Logic
                    // We calculated effectiveStack at start of botMove
                    // effectiveStack is total chips involved (bet + stack)
                    // limit raiseAmt to effectiveStack
                    if (raiseAmt > effectiveStack) {
                        raiseAmt = effectiveStack;
                    }

                    this.lastActions[bot.id] = `RAISE $${raiseAmt}`;
                    if (bot.chips >= raiseAmt) this.placeBetLogic(bot, raiseAmt);
                    else this.placeBetLogic(bot, bot.chips); // All-in fallback
                } else if (action === 'call') {
                    this.lastActions[bot.id] = `CALL $${toCall}`;
                    if (bot.chips >= toCall) this.placeBetLogic(bot, this.currentBet);
                    else this.fold(bot);
                } else if (action === 'check') {
                    this.lastActions[bot.id] = 'CHECK';
                    this.placeBetLogic(bot, this.currentBet);
                } else {
                    this.lastActions[bot.id] = 'FOLD';
                    this.fold(bot);
                }

                // Check Game End IMMEDIATELY after Bot action
                const active = this.players.filter(p => !p.fold);
                if (active.length === 1) {
                    // Force winner resolution
                    setTimeout(() => this.resolveWinner(active[0]), 500);
                    return;
                }
            }

            fold(player = this.players[0]) {
                player.fold = true;
                this.lastActions[player.id] = 'FOLD';

                // Log Folded Hand
                if (player.isBot) {
                    const handStr = player.hand.map(c => `${c.rank}${c.suit}`).join(' ');
                    console.log(`[POKER] ${player.name} FOLDED: ${handStr}`);
                }

                if (!this.actedThisRound.includes(player.id)) {
                    this.actedThisRound.push(player.id);
                }
                this.updateUI(`${player.name} Folds`);
                this.nextTurn();
            }

            checkCall(player = this.players[0]) {
                if (!this.inHand) return;
                const toCall = this.currentBet - player.bet;
                if (toCall > 0) {
                    this.lastActions[player.id] = `CALL $${toCall}`;
                } else {
                    this.lastActions[player.id] = 'CHECK';
                }
                if (player.chips >= toCall) {
                    this.placeBetLogic(player, this.currentBet);
                } else {
                    this.placeBetLogic(player, player.bet + player.chips);
                }
            }

            raise(player = this.players[0]) {
                if (!this.inHand) return;

                const sliderVal = parseInt(document.getElementById('poker-raise-slider').value);
                const raiseAmt = player.bet + sliderVal; // Total bet = current in + raise amount

                this.lastActions[player.id] = `RAISE $${sliderVal}`;

                if (player.chips >= sliderVal) {
                    this.placeBetLogic(player, raiseAmt);
                }
            }

            updateRaiseVal(val) {
                document.getElementById('poker-raise-val').innerText = `$${val}`;
            }

            placeBetLogic(player, totalTargetAmount, isBlind = false) {
                let needed = totalTargetAmount - player.bet;
                if (needed <= 0 && !isBlind && totalTargetAmount < this.currentBet) return;

                if (needed === 0 && !isBlind) {
                    // Check action
                    this.actedThisRound.push(player.id);
                    this.nextTurn();
                    return;
                }

                if (player.chips < needed) {
                    needed = player.chips;
                    totalTargetAmount = player.bet + needed;
                }

                // Deduct
                if (player.id === 0) {
                    GameConfig.deduct(needed);
                    this.players[0].chips = GameConfig.credits; // Sync
                } else {
                    player.chips -= needed;
                }

                this.pot += needed;

                // Track raises
                if (totalTargetAmount > this.currentBet && !isBlind) {
                    this.raisesCount++;
                }

                player.bet = totalTargetAmount;

                if (player.bet > this.currentBet) this.currentBet = player.bet;

                // Mark player as having acted
                if (!isBlind && !this.actedThisRound.includes(player.id)) {
                    this.actedThisRound.push(player.id);
                }

                if (!isBlind) this.nextTurn();
            }

            nextTurn() {
                this.turnIdx = (this.turnIdx + 1) % 5;
                this.startTurn();
            }

            advancePhase() {
                this.players.forEach(p => p.bet = 0);
                this.currentBet = 0;
                this.raisesCount = 0; // Reset raise counter
                this.actedThisRound = []; // Reset who has acted

                if (this.gamePhase === 'preflop') {
                    this.gamePhase = 'flop';
                    this.communityCards.push(this.deck.pop(), this.deck.pop(), this.deck.pop());
                } else if (this.gamePhase === 'flop') {
                    this.gamePhase = 'turn';
                    this.communityCards.push(this.deck.pop());
                } else if (this.gamePhase === 'turn') {
                    this.gamePhase = 'river';
                    this.communityCards.push(this.deck.pop());
                } else if (this.gamePhase === 'river') {
                    this.gamePhase = 'showdown';
                    this.resolveShowdown();
                    return;
                }

                // Post-flop action starts left of dealer (SB)
                this.turnIdx = (this.dealerIdx + 1) % 5;
                this.startTurn();
            }

            resolveShowdown() {
                const active = this.players.filter(p => !p.fold);
                let bestVal = -1;
                let winners = [];

                active.forEach(p => {
                    const exactScore = this.getLegacyHandScore(p.hand.concat(this.communityCards));
                    if (exactScore > bestVal) {
                        bestVal = exactScore;
                        winners = [p];
                    } else if (exactScore === bestVal) {
                        winners.push(p);
                    }
                });

                const share = Math.floor(this.pot / winners.length);
                winners.forEach(w => {
                    if (w.id === 0) {
                        GameConfig.add(share);
                        this.updateHumanChips();
                    } else {
                        w.chips += share;
                    }
                });

                this.updateUI(`Winner: ${winners.map(w => w.name).join(', ')}`);
                this.pot = 0;

                this.endHandState();
            }

            resolveWinner(winner) {
                if (winner.id === 0) {
                    GameConfig.add(this.pot);
                    this.updateHumanChips();
                } else {
                    winner.chips += this.pot;
                }
                this.updateUI(`${winner.name} Wins ${this.pot}!`);
                this.pot = 0;

                this.endHandState();
            }

            endHandState() {
                this.inHand = false;
                this.gamePhase = 'round_over'; // Keep cards visible!
                document.getElementById('poker-btn-deal').classList.remove('hidden');
                document.getElementById('poker-btn-fold').disabled = true;
                document.getElementById('poker-btn-check').disabled = true;
                document.getElementById('poker-btn-raise').disabled = true;
            }

            // --- EVALUATION LOGIC ---
            evaluateHandStrength(hand, shared) {
                // Effective Stack Calculation
                const humanStack = this.players[0].chips + this.players[0].bet;
                // ... (Logic handled in botMove, this method just returns raw strength score)

                // Preflop logic is handled inside botMove now, but this might be called by it?
                // Actually botMove calls this first.
                // Wait, botMove Overwrites 'strength' if it is Preflop.
                // So this function is primarily for Postflop.

                const total = hand.concat(shared || []);
                const score = this.getLegacyHandScore(total);
                // Normalize approximate
                // Type 4 (Straight) * 1M = 4M. 4M / 5M = 0.8 (Monster Bucket)
                return Math.min(score / 5000000, 1.0);
            }

            getLegacyHandScore(cards) {
                // Returns integer: Type * 1,000,000 + HighCard * 10,000 + ...
                if (cards.length < 5) return 0;

                // Helper to get counts
                const ranks = cards.map(c => c.value).sort((a, b) => b - a);
                const suits = cards.map(c => c.suit);

                const counts = {};
                ranks.forEach(r => counts[r] = (counts[r] || 0) + 1);

                // Flush?
                const suitCounts = {};
                suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
                const flushSuit = Object.keys(suitCounts).find(s => suitCounts[s] >= 5);
                const isFlush = !!flushSuit;

                // Straight?
                const uniqueRanks = [...new Set(ranks)];
                let isStraight = false;
                let topStraight = 0;
                for (let i = 0; i <= uniqueRanks.length - 5; i++) {
                    if (uniqueRanks[i] - uniqueRanks[i + 4] === 4) {
                        isStraight = true;
                        topStraight = uniqueRanks[i];
                        break;
                    }
                }
                // Wheel straight (A,5,4,3,2)
                if (!isStraight && uniqueRanks.includes(14) && uniqueRanks.includes(2) && uniqueRanks.includes(3) && uniqueRanks.includes(4) && uniqueRanks.includes(5)) {
                    isStraight = true;
                    topStraight = 5;
                }

                const countVals = Object.values(counts);
                const isQuads = countVals.includes(4);
                const isTrips = countVals.includes(3);
                const pairCount = countVals.filter(v => v === 2).length;
                const isFullHouse = isTrips && pairCount >= 1; // Or two trips logic ignored slightly

                // Score Calculation
                let type = 0; // High Card
                if (isFlush && isStraight) type = 8; // Straight Flush (ignore Royal for now)
                else if (isQuads) type = 7;
                else if (isFullHouse) type = 6;
                else if (isFlush) type = 5;
                else if (isStraight) type = 4;
                else if (isTrips) type = 3;
                else if (pairCount >= 2) type = 2; // Two Pair
                else if (pairCount === 1) type = 1; // One Pair

                // Tie breaking (High cards)
                // Simplified: Just add top rank value
                return (type * 1000000) + (ranks[0] * 10000) + (ranks[1] * 100) + ranks[2];
            }

            updateUI(msg) {
                document.getElementById('poker-status').innerText = msg;
                document.getElementById('poker-pot').innerText = `$${this.pot}`;
                document.getElementById('poker-current-bet').innerText = `$${this.currentBet}`;

                // Enable/Disable buttons based on turn
                const myTurn = (this.turnIdx === 0 && this.gamePhase !== 'showdown');
                document.getElementById('poker-btn-fold').disabled = !myTurn;
                document.getElementById('poker-btn-check').disabled = !myTurn;
                document.getElementById('poker-btn-raise').disabled = !myTurn;

                // Check/Call Text
                const btn = document.getElementById('poker-btn-check');
                const cost = this.currentBet - this.players[0].bet;
                btn.innerText = cost > 0 ? `Call ($${cost})` : 'Check';

                // Update Slider Logic
                if (myTurn) {
                    const slider = document.getElementById('poker-raise-slider');
                    const p = this.players[0];
                    const maxRaise = p.chips;

                    // Min Raise logic
                    const minTotal = Math.max(this.currentBet * 2, this.selectedTable.bb * 2);
                    const minAdd = minTotal - p.bet;

                    if (maxRaise < minAdd) {
                        // Only All-in option
                        slider.min = maxRaise;
                        slider.max = maxRaise;
                        slider.value = maxRaise;
                    } else {
                        slider.min = minAdd;
                        slider.max = maxRaise;
                        // If current value is invalid, reset to min
                        if (parseInt(slider.value) < minAdd) slider.value = minAdd;
                    }
                    this.updateRaiseVal(slider.value);
                } else {
                    document.getElementById('poker-raise-val').innerText = 'Wait';
                }
            }

            draw() {
                this.ctx.fillStyle = '#0f3a28'; // Felt Green (Darker)
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Table Border
                this.ctx.strokeStyle = '#d4af37';
                this.ctx.lineWidth = 10;
                this.ctx.beginPath();
                this.ctx.ellipse(this.width / 2, this.height / 2, this.width / 2 - 20, this.height / 2 - 40, 0, 0, Math.PI * 2);
                this.ctx.stroke();

                // Draw Players
                const positions = [
                    { x: this.width / 2, y: this.height - 60 }, // Human
                    { x: 60, y: this.height / 2 + 50 },
                    { x: 60, y: this.height / 2 - 50 },
                    { x: this.width - 60, y: this.height / 2 - 50 },
                    { x: this.width - 60, y: this.height / 2 + 50 }
                ];

                this.ctx.fillStyle = '#fbbf24';
                this.ctx.font = 'bold 20px Inter';
                this.ctx.textAlign = 'center';
                // Draw Pot in Center
                this.ctx.fillText(`Pot: $${this.pot}`, this.width / 2, this.height / 2 - 20);

                this.players.forEach((p, i) => {
                    const pos = positions[i];

                    // Avatar/Chips
                    this.ctx.fillStyle = (i === this.turnIdx && this.gamePhase !== 'showdown') ? '#fbbf24' : '#1e293b';
                    this.ctx.beginPath();
                    this.ctx.arc(pos.x, pos.y, 30, 0, Math.PI * 2);
                    this.ctx.fill();

                    this.ctx.fillStyle = '#fff';
                    this.ctx.textAlign = 'center';
                    this.ctx.font = '10px Inter';
                    this.ctx.fillText(p.name, pos.x, pos.y + 45);
                    this.ctx.fillStyle = '#fbbf24';

                    // Display Chips (Credits for Human)
                    let displayChips = p.chips;
                    if (p.id === 0) displayChips = GameConfig.credits;

                    this.ctx.fillText(`$${displayChips.toFixed(0)}`, pos.x, pos.y + 55);

                    // Dealer Button
                    if (this.dealerIdx === i) {
                        this.ctx.fillStyle = '#fff';
                        this.ctx.beginPath();
                        this.ctx.arc(pos.x + 25, pos.y - 25, 8, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.fillStyle = '#000';
                        this.ctx.font = 'bold 10px sans-serif';
                        this.ctx.fillText('D', pos.x + 25, pos.y - 22);
                    }

                    // Bet Badge (Current Round)
                    if (p.bet > 0) {
                        this.ctx.fillStyle = '#10b981';
                        this.ctx.font = 'bold 12px Inter';
                        this.ctx.fillText(`$${p.bet}`, pos.x, pos.y - 40);
                    }

                    // Action Indicator (CALL, FOLD, RAISE, CHECK)
                    if (this.lastActions[i] && this.lastActions[i].length > 0) {
                        this.ctx.fillStyle = '#fbbf24';
                        this.ctx.font = 'bold 11px Inter';
                        this.ctx.fillText(this.lastActions[i], pos.x, pos.y + 70);
                    }

                    // Reveal Cards: Humans always, Bots only at Showdown/Round Over if not folded
                    if (!p.fold && p.hand.length > 0) {
                        const show = (i === 0 || this.gamePhase === 'showdown' || this.gamePhase === 'round_over');
                        this.drawCard(p.hand[0], pos.x - 15, pos.y - 10, show);
                        this.drawCard(p.hand[1], pos.x + 15, pos.y - 10, show);
                    }
                });

                // Community Cards
                const cx = this.width / 2;
                const cy = this.height / 2;
                this.communityCards.forEach((c, i) => {
                    this.drawCard(c, cx - 60 + (i * 30), cy, true);
                });
            }

            drawCard(card, x, y, faceUp) {
                const w = 24;
                const h = 36;
                this.ctx.translate(x, y);
                if (faceUp) {
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillRect(-w / 2, -h / 2, w, h);
                    this.ctx.textAlign = 'center';
                    this.ctx.font = 'bold 12px serif';
                    this.ctx.fillStyle = (card.suit === '‚ô•' || card.suit === '‚ô¶') ? '#ef4444' : '#000';
                    this.ctx.fillText(card.rank + card.suit, 0, 4);
                } else {
                    this.ctx.fillStyle = '#ef4444'; // Red back
                    this.ctx.fillRect(-w / 2, -h / 2, w, h);
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.strokeRect(-w / 2 + 2, -h / 2 + 2, w - 4, h - 4);
                }
                this.ctx.translate(-x, -y);
            }

            animate() {
                this.draw(); // No physics really, just render loop
                requestAnimationFrame(() => this.animate());
            }
        }

        // --- STATS GRAPH ---
        class StatsGraph {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.animate();
            }
            resize() {
                if (!this.canvas.offsetParent) return;
                this.width = this.canvas.parentElement.clientWidth;
                this.height = this.canvas.parentElement.clientHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
            }
            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                const history = GameConfig.history;
                if (history.length < 2) {
                    this.ctx.fillStyle = '#94a3b8';
                    this.ctx.textAlign = 'center';
                    this.ctx.font = '16px Inter';
                    this.ctx.fillText("Play more games to see data.", this.width / 2, this.height / 2);
                    return;
                }

                // Chart Margins
                const padTop = 40; const padBot = 40; const padL = 60; const padR = 20;
                const plotW = this.width - padL - padR;
                const plotH = this.height - padTop - padBot;

                // Scales
                const maxBal = Math.max(1000, ...history.map(h => h.bal));
                const minBal = Math.min(1000, ...history.map(h => h.bal));
                const range = maxBal - minBal || 100;

                // Draw Grid
                this.ctx.strokeStyle = '#334155'; this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                // 3 Lines: Max, Mid, Min
                [0, 0.5, 1].forEach(r => {
                    const y = padTop + (plotH * r);
                    this.ctx.moveTo(padL, y); this.ctx.lineTo(this.width - padR, y);
                    this.ctx.fillStyle = '#94a3b8'; this.ctx.font = '10px Inter'; this.ctx.textAlign = 'right';
                    const val = maxBal - (range * r);
                    this.ctx.fillText(val.toFixed(0), padL - 10, y + 4);
                });
                this.ctx.stroke();

                // Draw Baseline (1000)
                if (minBal < 1000 && maxBal > 1000) {
                    const r1000 = (maxBal - 1000) / range;
                    const y1000 = padTop + (plotH * r1000);
                    this.ctx.strokeStyle = '#64748b'; this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath(); this.ctx.moveTo(padL, y1000); this.ctx.lineTo(this.width - padR, y1000); this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }

                // Draw Line
                this.ctx.beginPath();
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 2;

                history.forEach((pt, i) => {
                    const x = padL + ((i / (history.length - 1)) * plotW);
                    const y = padTop + ((1 - ((pt.bal - minBal) / range)) * plotH);
                    if (i === 0) this.ctx.moveTo(x, y); else this.ctx.lineTo(x, y);
                });
                this.ctx.stroke();

                // Draw Gradient
                const gradient = this.ctx.createLinearGradient(0, padTop, 0, this.height - padBot);
                gradient.addColorStop(0, 'rgba(59, 130, 246, 0.2)');
                gradient.addColorStop(1, 'rgba(59, 130, 246, 0.0)');
                this.ctx.fillStyle = gradient;
                this.ctx.lineTo(padL + plotW, this.height - padBot);
                this.ctx.lineTo(padL, this.height - padBot);
                this.ctx.fill();
            }
            animate() { this.draw(); requestAnimationFrame(() => this.animate()); }
        }

        // --- UPDATE LOG DATA ---
        const APP_VERSION = "1.5.2"; // Updated to match current state
        const APP_UPDATES = [
            {
                version: "v1.5 - Cases Overhaul",
                date: "2024-10-27",
                changes: [
                    "Added 10 distinct Cases ranging from $10 to $1,000,000.",
                    "Implemented visual item drops with varying rarities.",
                    "Enhanced spinning animation with tape visualizer.",
                    "Added Case Selection Menu with previews."
                ]
            },
            {
                version: "v1.4 - Poker AI Overhaul",
                date: "2026-01-13",
                changes: [
                    "Improved Bot AI strategies and aggression",
                    "Added effective stack capping (bots respect player stack)",
                    "Added 'Showdown' all-in fast forward",
                    "Visual improvements to Poker table"
                ]
            },
            {
                version: "v1.3 - Sidebar & UI",
                date: "2026-01-13",
                changes: [
                    "Sidebar is now scrollable for smaller screens",
                    "Added this Update Log feature",
                    "Cleaned up UI layout"
                ]
            }
        ];

        // --- MANAGER ---
        const GameUI = {
            plinko: null, dice: null, blackjack: null, mines: null, rocket: null, stats: null, slots: null, roulette: null, scratch: null, cases: null, poker: null,
            activeGame: 'plinko', dropInterval: null,

            // Update Log Logic
            toggleUpdates() {
                const modal = document.getElementById('updates-modal');
                const isHidden = modal.classList.contains('hidden');

                if (isHidden) {
                    this.renderUpdates();
                    modal.classList.remove('hidden');
                } else {
                    modal.classList.add('hidden');
                }
            },

            async checkForUpdates() {
                try {
                    const response = await fetch('https://raw.githubusercontent.com/Notmoodo9/versionHist/refs/heads/main/version.txt?nocache=' + Date.now());
                    if (!response.ok) return;
                    const latestVersion = (await response.text()).trim();

                    // Simple version comparison assuming semantic versioning "vX.Y.Z" or just "X.Y.Z"
                    const normalize = (v) => v.replace(/^v/, '').split('.').map(Number);
                    const currentParts = normalize(APP_VERSION);
                    const latestParts = normalize(latestVersion);

                    let isNewer = false;
                    for (let i = 0; i < 3; i++) { // compare major, minor, patch
                        const lat = latestParts[i] || 0;
                        const cur = currentParts[i] || 0;
                        if (lat > cur) { isNewer = true; break; }
                        if (lat < cur) break;
                    }

                    if (isNewer) {
                        const modal = document.getElementById('update-modal');
                        document.getElementById('update-version-text').innerText = `Current: ${APP_VERSION} -> New: ${latestVersion}`;
                        modal.classList.remove('hidden');
                    }
                } catch (e) {
                    console.log("Update check failed", e);
                }
            },
            renderUpdates() {
                const container = document.getElementById('updates-content');
                container.innerHTML = APP_UPDATES.map(update => `
                    <div class="border-l-2 border-emerald-500 pl-4">
                        <div class="flex justify-between items-baseline mb-2">
                            <h3 class="text-white font-bold text-lg">${update.version}</h3>
                            <span class="text-xs text-slate-500 font-mono">${update.date}</span>
                        </div>
                        <ul class="space-y-1">
                            ${update.changes.map(change => `
                                <li class="text-slate-300 text-sm flex items-start gap-2">
                                    <span class="text-emerald-500 mt-1">‚Ä¢</span>
                                    <span>${change}</span>
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                `).join('');
            },

            init() {
                GameConfig.init();

                // Auto-Update Check
                this.checkForUpdates();
                setInterval(() => this.checkForUpdates(), 600000); // 10 mins

                this.plinko = new PlinkoGame('plinko-canvas');
                this.roulette = new RouletteGame('roulette-canvas');
                this.slots = new SlotsGame('slots-canvas');
                this.dice = new DiceGame('dice-canvas');
                this.blackjack = new BlackjackGame('blackjack-canvas');
                this.mines = new MinesGame();
                this.rocket = new RocketGame('rocket-canvas');
                this.stats = new StatsGraph('stats-canvas');
                this.scratch = new ScratchGame();
                this.cases = new CasesGame('cases-canvas');
                this.poker = new PokerGame('poker-canvas');

                // Desktop Nav Listeners
                document.getElementById('play-btn-plinko').addEventListener('click', () => this.playPlinko());
                document.getElementById('rows-select').addEventListener('change', (e) => this.plinko.setConfiguration(e.target.value));

                // Spacebar Logic
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();

                        if (this.activeGame === 'plinko') {
                            if (!this.dropInterval) {
                                this.playPlinko();
                                this.dropInterval = setInterval(() => this.playPlinko(), 75);
                            }
                        } else if (this.activeGame === 'slots') {
                            this.slots.spin();
                        } else if (this.activeGame === 'rocket') {
                            if (this.rocket.gameState === 'running') this.rocket.eject();
                            else this.rocket.launch();
                        } else if (this.activeGame === 'cases') {
                            this.cases.spin();
                        }
                    }
                });
                document.addEventListener('keyup', (e) => {
                    if (e.code === 'Space') {
                        clearInterval(this.dropInterval);
                        this.dropInterval = null;
                    }
                });
            },

            switchGame(game) {
                this.activeGame = game;
                const games = ['plinko', 'roulette', 'dice', 'blackjack', 'mines', 'rocket', 'stats', 'slots', 'scratch', 'cases', 'poker'];

                // Update Desktop and Mobile Nav Styles
                games.forEach(g => {
                    // Desktop Sidebar
                    const deskBtn = document.getElementById(`nav-${g}`);
                    if (deskBtn) {
                        deskBtn.className = g === game
                            ? 'active-game-btn w-full flex items-center gap-3 px-4 py-3 rounded-lg border border-transparent shadow-sm transition'
                            : 'w-full flex items-center gap-3 px-4 py-3 text-slate-400 rounded-lg border border-transparent transition hover:bg-slate-800 hover:text-white';
                    }

                    // Mobile Horizontal Nav
                    const mobBtn = document.getElementById(`mob-nav-${g}`);
                    if (mobBtn) {
                        mobBtn.className = g === game
                            ? 'flex-shrink-0 px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-bold shadow-lg shadow-blue-900/20 whitespace-nowrap'
                            : 'flex-shrink-0 px-4 py-2 bg-slate-800 text-slate-400 rounded-lg text-sm font-bold whitespace-nowrap';
                    }

                    // Visibility toggling
                    const controls = document.getElementById(`controls-${g}`);
                    const viz = document.getElementById(`visualizer-${g}`);
                    if (g === game) {
                        if (controls) controls.classList.remove('hidden-panel');
                        if (viz) viz.classList.remove('hidden-panel');

                        // Resize active
                        if (g === 'rocket') this.rocket.resize();
                        if (g === 'plinko') this.plinko.resize();
                        if (g === 'cases') this.cases.resize();
                        if (g === 'poker') this.poker.resize();
                        if (g === 'slots') this.slots.resize();
                        if (g === 'roulette') this.roulette.resize();
                        if (g === 'dice') this.dice.resize();
                        if (g === 'blackjack') this.blackjack.resize();
                        if (g === 'stats') this.stats.resize();
                        if (g === 'scratch') this.scratch.resetPreview();
                    } else {
                        if (controls) controls.classList.add('hidden-panel');
                        if (viz) viz.classList.add('hidden-panel');
                    }
                });
            },

            adjustBet(game, mult) {

                const input = document.getElementById(`bet-input-${game}`);
                let val = parseFloat(input.value) * mult;
                if (GameConfig.credits < val) val = GameConfig.credits;
                if (val < 1) val = 1;
                input.value = Math.floor(val);
            },
            playPlinko() {
                const val = parseFloat(document.getElementById('bet-input-plinko').value);
                if (this.validateBet(val)) this.plinko.dropBall(val);
            },
            playRoulette(type) {
                const val = parseFloat(document.getElementById('bet-input-roulette').value);

                // Special handling for single number input
                let betValue = null;
                if (type === 'number') {
                    const numInput = document.getElementById('roulette-single-num');
                    const num = parseInt(numInput.value);
                    if (isNaN(num) || num < 1 || num > 36) {
                        alert("Please enter a valid number (1-36)");
                        return;
                    }
                    betValue = num;
                }

                if (this.validateBet(val)) {
                    this.roulette.spin(type, betValue, val);
                }
            },
            playDice(type) {
                const val = parseFloat(document.getElementById('bet-input-dice').value);
                if (this.dice.rolling) return;
                if (this.validateBet(val)) this.dice.roll(val, type);
            },
            blackjackAction(act) {
                const val = parseFloat(document.getElementById('bet-input-blackjack').value);
                if (act === 'deal') {
                    if (this.blackjack.gameState !== 'idle' && this.blackjack.gameState !== 'result') return;
                    if (this.validateBet(val)) {
                        this.blackjack.startHand(val);
                        this.updateBJButtons();
                    }
                }
                else if (act === 'hit') { this.blackjack.hit(); this.updateBJButtons(); }
                else if (act === 'stand') { this.blackjack.stand(); this.updateBJButtons(); }
                else if (act === 'split') { this.blackjack.split(); this.updateBJButtons(); }
                else if (act === 'double') { this.blackjack.doubleDown(); this.updateBJButtons(); }
            },
            // Removed toggleBJStats()
            updateBJButtons() {
                const s = this.blackjack.gameState;
                const d = document.getElementById('bj-btn-deal');
                const h = document.getElementById('bj-btn-hit');
                const st = document.getElementById('bj-btn-stand');
                const split = document.getElementById('bj-btn-split');
                const double = document.getElementById('bj-btn-double');

                if (s === 'playing') {
                    d.disabled = true; d.classList.add('opacity-50');
                    h.disabled = false; h.classList.remove('opacity-50');
                    st.disabled = false; st.classList.remove('opacity-50');

                    // Split Logic
                    if (this.blackjack.canSplit()) {
                        split.classList.remove('hidden');
                        split.disabled = false; split.classList.remove('opacity-50');
                        // Make Double take only 1 col if Split is visible
                        double.classList.remove('col-span-2');
                    } else {
                        split.classList.add('hidden');
                        // Make Double take full width if Split is hidden for cleaner UI
                        double.classList.add('col-span-2');
                    }

                    // Double Logic
                    if (this.blackjack.canDouble()) {
                        double.classList.remove('hidden');
                        double.disabled = false; double.classList.remove('opacity-50');
                    } else {
                        double.disabled = true; double.classList.add('opacity-50');
                    }

                } else {
                    d.disabled = false; d.classList.remove('opacity-50');
                    h.disabled = true; h.classList.add('opacity-50');
                    st.disabled = true; st.classList.add('opacity-50');

                    split.classList.add('hidden');
                    double.classList.add('hidden'); // Hide Double when not playing
                }
            },
            validateBet(amt) {
                if (isNaN(amt) || amt <= 0) { alert("Invalid Bet"); return false; }
                if (!GameConfig.deduct(amt)) { alert("No Credits"); return false; }
                return true;
            }
        };

        window.onload = () => GameUI.init();
    </script>
    <!-- Auto-Update Modal -->
    <div id="update-modal"
        class="fixed inset-0 bg-black/80 backdrop-blur-sm hidden z-50 flex items-center justify-center">
        <div class="bg-slate-800 border border-emerald-500/30 rounded-xl p-8 max-w-md w-full shadow-2xl relative">
            <button onclick="document.getElementById('update-modal').classList.add('hidden')"
                class="absolute top-4 right-4 text-slate-400 hover:text-white">
                ‚úï
            </button>
            <div class="text-center">
                <div class="text-6xl mb-4">üöÄ</div>
                <h2 class="text-2xl font-bold text-white mb-2">New Version Available!</h2>
                <p id="update-version-text" class="text-emerald-400 font-mono text-sm mb-6"></p>
                <p class="text-slate-300 mb-6">
                    A new update has been released. Please refresh your page to apply the latest changes.
                </p>
                <div class="bg-amber-900/30 border border-amber-500/30 p-4 rounded-lg mb-6">
                    <p class="text-amber-200 text-xs font-bold text-left mb-1">‚ö† IMPORTANT:</p>
                    <p class="text-amber-100 text-xs text-left">
                        Before refreshing, ensure you have saved your **Backup Code** from the Settings menu if you are
                        playing on google sites!
                    </p>
                </div>
                <button onclick="window.location.reload()"
                    class="w-full bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-3 rounded-lg shadow-lg transition-colors">
                    REFRESH NOW
                </button>
                <button onclick="document.getElementById('update-modal').classList.add('hidden')"
                    class="w-full mt-3 text-slate-400 hover:text-white text-sm">
                    Remind me later
                </button>
            </div>
        </div>
    </div>

</body>

</html>
